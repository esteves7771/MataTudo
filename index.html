import React, { useEffect, useRef, useState } from "react";

// MataTudo — Alpha 5 (React Canvas build)
// ------------------------------------------------------------
// Fixed: previous canvas contained a full HTML file which a React
// bundler tries to parse as JS → "Unexpected token (1:0)" at "<!doctype...".
// This rewrite restores a proper React component with all Alpha 5
// features:
//  - In‑game music (GitHub MP3) that starts on gameplay and stops on Game Over/menu (toggle with M)
//  - Infinite levels (+1 every 50 kills)
//  - Difficulty scaling (spawn rate & bot speed scale with level)
//  - Elite bots more frequent at higher levels
//  - Obstacle regeneration on level‑up with fade‑out → swap → fade‑in
//  - HUD: Score, HP, Level, and "Level Up!" popup
//  - Stable collision, bullets stop on walls, medkits every 30 kills
//  - Menu → 2s Countdown → Playing → Game Over (R/click to restart)
//
// Notes:
//  - Music URL can be overridden by setting window.MT_TRACK_URL at runtime.
//  - Uses Tailwind utility classes available in this environment.

export default function MiniCanvasShooterAlpha5() {
  // ---------- UI refs/state ----------
  const canvasRef = useRef(null);
  const stateRef = useRef(null); // authoritative game state
  const rafRef = useRef(0);

  const [mounted, setMounted] = useState(false);
  const [running, setRunning] = useState(true);
  const [muted, setMuted] = useState(false);
  const [volume, setVolume] = useState(0.7);

  // ---------- Constants/Helpers ----------
  const W = 900, H = 560, MAP_MARGIN = 12, LEVEL_KILLS = 50;
  const MUSIC_URL = (typeof window !== 'undefined' && window.MT_TRACK_URL) ||
    "https://raw.githubusercontent.com/esteves7771/MataTudo/main/retro-synthwave-gaming-music-270173.mp3";

  const clamp = (v, a, b) => Math.max(a, Math.min(b, v));
  const rectOverAny = (rect, arr) => arr.some(o => !(rect.x + rect.w < o.x || rect.x > o.x + o.w || rect.y + rect.h < o.y || rect.y > o.y + o.h));
  const rectCircleOverlap = (cx, cy, r, o) => {
    const nx = clamp(cx, o.x, o.x + o.w), ny = clamp(cy, o.y, o.y + o.h);
    const dx = cx - nx, dy = cy - ny; return dx*dx + dy*dy <= r*r;
  };
  const bulletHitsObstacle = (b, o) => (
    b.x + b.r > o.x && b.x - b.r < o.x + o.w && b.y + b.r > o.y && b.y - b.r < o.y + o.h
  );
  const posIsFree = (x, y, r, s) => {
    if (x < MAP_MARGIN + r || x > W - MAP_MARGIN - r || y < MAP_MARGIN + r || y > H - MAP_MARGIN - r) return false;
    if (rectOverAny({ x: x - r, y: y - r, w: r*2, h: r*2 }, s.obstacles)) return false;
    if (Math.hypot(x - s.player.x, y - s.player.y) < 80) return false;
    return true;
  };

  // tiny runtime tests (won't crash UI if fail, but helps in dev)
  useEffect(() => {
    try {
      console.assert(clamp(5,0,10)===5, 'clamp mid');
      const o={x:10,y:10,w:20,h:20};
      console.assert(rectCircleOverlap(5,20,6,o)===true, 'circle edge');
      console.assert(bulletHitsObstacle({x:15,y:15,r:2},o)===true, 'bullet hit');
    } catch {}
  }, []);

  // Keep volume/mute in sync with audio master
  useEffect(() => {
    const a = stateRef.current?.audio; if (!a) return;
    if (a.master) a.master.gain.value = muted ? 0 : volume;
    if (a.musicEl) a.musicEl.volume = muted ? 0 : volume;
  }, [muted, volume]);

  useEffect(() => {
    const canvas = canvasRef.current; if (!canvas) return;
    const ctx = canvas.getContext('2d', { alpha: false }); if (!ctx) return;

    // -------------- Build ground pattern --------------
    const patCanvas = document.createElement('canvas'); patCanvas.width=64; patCanvas.height=64;
    const pg = patCanvas.getContext('2d');
    pg.fillStyle = '#27303a'; pg.fillRect(0,0,64,64);
    for (let i=0;i<140;i++){ pg.fillStyle = `rgba(255,255,255,${0.06 + Math.random()*0.06})`; pg.fillRect(Math.random()*64, Math.random()*64, 1, 1); }
    pg.strokeStyle='rgba(0,0,0,0.12)';
    for (let x=0;x<=64;x+=16){ pg.beginPath(); pg.moveTo(x,0); pg.lineTo(x,64); pg.stroke(); }
    for (let y=0;y<=64;y+=16){ pg.beginPath(); pg.moveTo(0,y); pg.lineTo(64,y); pg.stroke(); }
    const groundPattern = ctx.createPattern(patCanvas,'repeat');

    // -------------- Authoritative state --------------
    const s = {
      ctx,
      time: 0,
      lastTime: 0,
      mode: 'intro', // 'intro' | 'menu' | 'countdown' | 'playing' | 'gameover'
      introTime: 0,
      countdown: 2,
      level: 1, levelUpFlash: 0,
      score: 0, bestScore: 0,
      lastMedkitAtScore: 0, lastEliteAtScore: 0,
      player: { x: W/2, y: H/2, r: 12, speed: 240, hp: 100, fireCooldown: 0, flashTimer: 0, hitCooldown: 0 },
      keys: {}, mouse: { x: W/2, y: H/2, down: false },
      bullets: [], bots: [], particles: [], medkits: [],
      groundPattern,
      spawnTimer: 0,
      firstWaveRemaining: 4, firstWaveInterval: 0.4, firstWaveTimer: 0.4,
      obstacles: [
        { x:280,y:180,w:90,h:90 },
        { x:610,y:340,w:120,h:70 },
        { x:440,y: 90,w:70,h:70 },
        { x:120,y:400,w:140,h:40 },
      ],
      obstacleAlpha: 1, obstaclePhase: 'stable', obstacleFadeT: 0,
      // audio
      audio: { ctx: null, master: null, sfxGain: null, musicEl: null }
    };

    try { const saved = localStorage.getItem('matatudo_best'); if (saved) s.bestScore = parseInt(saved,10)||0; } catch {}

    stateRef.current = s;

    // -------------- Audio (SFX via WebAudio, Music via HTMLAudio) --------------
    const ensureAC = () => {
      if (muted) return;
      if (!s.audio.ctx) {
        const AC = window.AudioContext || window.webkitAudioContext; if (!AC) return;
        const ac = new AC();
        const master = ac.createGain(); master.gain.value = volume; master.connect(ac.destination);
        const sfxGain = ac.createGain(); sfxGain.gain.value = 1.0; sfxGain.connect(master);
        s.audio.ctx = ac; s.audio.master = master; s.audio.sfxGain = sfxGain;
      } else if (s.audio.ctx.state === 'suspended') {
        s.audio.ctx.resume();
      }
    };
    const setMasterVolume = (x) => { if (s.audio.master) s.audio.master.gain.value = x; if (s.audio.musicEl) s.audio.musicEl.volume = muted?0:x; };
    const startMusic = () => {
      if (!s.audio.musicEl) {
        const el = new Audio(MUSIC_URL); el.loop = true; el.crossOrigin = 'anonymous'; el.preload = 'auto'; s.audio.musicEl = el;
      }
      if (!muted) { s.audio.musicEl.volume = volume; s.audio.musicEl.play().catch(()=>{}); }
    };
    const stopMusic = () => { if (s.audio.musicEl) { s.audio.musicEl.pause(); s.audio.musicEl.currentTime = 0; } };

    const quickBeep = (freq=800, dur=0.06, type='square', gain=0.03) => {
      if (muted) return; ensureAC(); if (!s.audio.ctx) return;
      const ac=s.audio.ctx, osc=ac.createOscillator(), g=ac.createGain();
      osc.type=type; osc.frequency.value=freq; g.gain.value=gain; osc.connect(g).connect(s.audio.sfxGain);
      const now = ac.currentTime; g.gain.setValueAtTime(gain,now); g.gain.exponentialRampToValueAtTime(0.0001, now+dur);
      osc.start(now); osc.stop(now+dur);
    };
    const noiseBurst = (dur=0.25, gain=0.05) => {
      if (muted) return; ensureAC(); if (!s.audio.ctx) return;
      const ac=s.audio.ctx; const buf=ac.createBuffer(1, ac.sampleRate*dur, ac.sampleRate); const data=buf.getChannelData(0);
      for (let i=0;i<data.length;i++) data[i]=(Math.random()*2-1)*0.6;
      const src=ac.createBufferSource(); src.buffer=buf; const g=ac.createGain(); g.gain.value=gain; const lp=ac.createBiquadFilter(); lp.type='lowpass'; lp.frequency.value=1200;
      src.connect(lp).connect(g).connect(s.audio.sfxGain);
      const now=ac.currentTime; g.gain.setValueAtTime(gain,now); g.gain.exponentialRampToValueAtTime(0.0001,now+dur); src.start(now);
    };
    const SFX = {
      shot: () => quickBeep(1100, 0.045, 'square', 0.03),
      hit:  () => quickBeep(280,  0.06,  'sine',   0.02),
      heal: () => quickBeep(900,  0.12,  'triangle', 0.035),
      death:(i=0.4)=>{ noiseBurst(0.22+0.15*i,0.04+0.06*i); quickBeep(200,0.3+0.15*i,'sawtooth',0.02+0.04*i); },
    };

    // -------------- Obstacles regen --------------
    const randomObstacles = () => {
      const count = 4 + Math.floor(Math.random()*3); // 4-6
      const obs = [];
      for (let i=0;i<count;i++){
        const t=Math.random();
        if (t < 0.33) {
          const w=60+Math.random()*120, h=60+Math.random()*120;
          const x=MAP_MARGIN+20+Math.random()*(W-2*(MAP_MARGIN+20)-w);
          const y=MAP_MARGIN+20+Math.random()*(H-2*(MAP_MARGIN+20)-h);
          obs.push({x,y,w,h});
        } else if (t < 0.66) {
          const w=160+Math.random()*160, h=30+Math.random()*50;
          const x=MAP_MARGIN+20+Math.random()*(W-2*(MAP_MARGIN+20)-w);
          const y=MAP_MARGIN+20+Math.random()*(H-2*(MAP_MARGIN+20)-h);
          obs.push({x,y,w,h});
        } else {
          const cx=MAP_MARGIN+80+Math.random()*(W-2*(MAP_MARGIN+80));
          const cy=MAP_MARGIN+60+Math.random()*(H-2*(MAP_MARGIN+60));
          const n=3+Math.floor(Math.random()*4);
          for (let j=0;j<n;j++){
            const w=40+Math.random()*60, h=40+Math.random()*60;
            const x=clamp(cx+(Math.random()*120-60), MAP_MARGIN+10, W-MAP_MARGIN-10-w);
            const y=clamp(cy+(Math.random()*100-50), MAP_MARGIN+10, H-MAP_MARGIN-10-h);
            obs.push({x,y,w,h});
          }
        }
      }
      const safe = { x: s.player.x-80, y: s.player.y-80, w: 160, h: 160 };
      const bad = obs.some(o => !(safe.x + safe.w < o.x || safe.x > o.x + o.w || safe.y + safe.h < o.y || safe.y > o.y + o.h));
      return bad ? s.obstacles : obs;
    };
    const triggerObstacleSwap = () => { s.obstaclePhase='fadeOut'; s.obstacleFadeT=0; };
    const updateObstacleFade = (dt) => {
      if (s.obstaclePhase==='stable') return;
      const DUR = 0.45; s.obstacleFadeT += dt; const t = clamp(s.obstacleFadeT / DUR, 0, 1);
      if (s.obstaclePhase==='fadeOut'){
        s.obstacleAlpha = 1 - t;
        if (s.obstacleFadeT >= DUR){ s.obstacles = randomObstacles(); s.obstaclePhase='fadeIn'; s.obstacleFadeT = 0; }
      } else {
        s.obstacleAlpha = t;
        if (s.obstacleFadeT >= DUR){ s.obstaclePhase='stable'; s.obstacleAlpha=1; }
      }
    };

    // -------------- Spawners --------------
    const spawnParticles = (x,y,color,count,size=2) => {
      for (let i=0;i<count;i++){
        const a = Math.random()*Math.PI*2, v = 40 + Math.random()*80;
        s.particles.push({ x,y, vx:Math.cos(a)*v, vy:Math.sin(a)*v, life:0.4+Math.random()*0.4, color, size });
      }
    };
    const spawnBot = (elite=false) => {
      let tries=0, x=0, y=0, r=elite?16:12;
      while (tries++<40){
        const edge=Math.floor(Math.random()*4);
        if (edge===0){ x=MAP_MARGIN+r+2; y=Math.random()*(H-2*MAP_MARGIN)+MAP_MARGIN; }
        else if (edge===1){ x=W-MAP_MARGIN-r-2; y=Math.random()*(H-2*MAP_MARGIN)+MAP_MARGIN; }
        else if (edge===2){ x=Math.random()*(W-2*MAP_MARGIN)+MAP_MARGIN; y=MAP_MARGIN+r+2; }
        else { x=Math.random()*(W-2*MAP_MARGIN)+MAP_MARGIN; y=H-MAP_MARGIN-r-2; }
        if (posIsFree(x,y,r,s)) break;
      }
      const base = 80+Math.random()*35; const hp = elite?200:40; const speed = base * (1 + 0.08*(s.level-1)) * (elite?0.9:1);
      const shootEvery = (0.9 + Math.random()*0.9) * (elite?0.85:1);
      s.bots.push({ x,y,r,speed,hp,fireCooldown:0,shootEvery,jitter:Math.random()*Math.PI*2, elite });
    };
    const trySpawnMedkit = () => {
      if (s.score>0 && s.score%30===0 && s.lastMedkitAtScore!==s.score){
        for (let i=0;i<60;i++){
          const r=10; const x=MAP_MARGIN+r + Math.random()*(W-2*(MAP_MARGIN+r)); const y=MAP_MARGIN+r + Math.random()*(H-2*(MAP_MARGIN+r));
          if (!posIsFree(x,y,r,s)) continue; s.medkits.push({ x,y,r,timeLeft:20 }); s.lastMedkitAtScore=s.score; break;
        }
      }
    };

    // -------------- Leveling --------------
    const maybeLevelUp = () => {
      const next = Math.floor(s.score / LEVEL_KILLS) + 1;
      if (next > s.level) { s.level = next; s.levelUpFlash = 2; triggerObstacleSwap(); }
    };

    // -------------- Start/Reset --------------
    const startGame = () => {
      ensureAC(); startMusic();
      s.player = { x:W/2, y:H/2, r:12, speed:240, hp:100, fireCooldown:0, flashTimer:0, hitCooldown:0 };
      s.bullets=[]; s.bots=[]; s.particles=[]; s.medkits=[];
      s.spawnTimer=0; s.score=0; s.lastEliteAtScore=0; s.lastMedkitAtScore=0;
      s.firstWaveRemaining=4; s.firstWaveTimer=s.firstWaveInterval;
      s.level=1; s.levelUpFlash=0; s.obstaclePhase='stable'; s.obstacleAlpha=1;
      s.mode='countdown'; s.countdown=2;
    };

    // -------------- Update --------------
    const update = (dt) => {
      s.time += dt; updateObstacleFade(dt);
      if (!running) return;

      if (s.mode==='intro'){ s.introTime += dt; if (s.introTime>1.6){ s.mode='menu'; stopMusic(); } return; }
      if (s.mode==='menu') return;
      if (s.mode==='countdown'){ s.countdown -= dt; if (s.countdown<=0){ s.mode='playing'; } return; }
      if (s.mode!=='playing') return;

      // spawn scaling with level
      s.spawnTimer -= dt;
      const spawnBase = Math.max(0.5, 1.6 - Math.min(60, s.score/5)*0.01);
      const spawnScaled = Math.max(0.25, spawnBase * (1 - 0.06*(s.level-1)));
      if (s.spawnTimer<=0){ const eliteChance = Math.min(0.5, 0.05*s.level); spawnBot(Math.random() < eliteChance); s.spawnTimer = spawnScaled; }
      if (s.firstWaveRemaining>0){ s.firstWaveTimer -= dt; if (s.firstWaveTimer<=0){ spawnBot(false); s.firstWaveRemaining--; s.firstWaveTimer=s.firstWaveInterval; } }
      if (s.score>0 && s.score%20===0 && s.lastEliteAtScore!==s.score){ spawnBot(true); s.lastEliteAtScore=s.score; }

      // player move
      const p = s.player; p.hitCooldown = Math.max(0, p.hitCooldown - dt); p.flashTimer = Math.max(0, p.flashTimer - dt);
      let ix=0, iy=0; if (s.keys['w']||s.keys['arrowup']) iy--; if (s.keys['s']||s.keys['arrowdown']) iy++; if (s.keys['a']||s.keys['arrowleft']) ix--; if (s.keys['d']||s.keys['arrowright']) ix++;
      const mag = Math.hypot(ix,iy) || 1; const mvx = ix/mag * p.speed * dt, mvy = iy/mag * p.speed * dt;
      let nx = clamp(p.x + mvx, MAP_MARGIN+p.r, W-MAP_MARGIN-p.r); if (!s.obstacles.some(o=>rectCircleOverlap(nx,p.y,p.r,o))) p.x = nx;
      let ny = clamp(p.y + mvy, MAP_MARGIN+p.r, H-MAP_MARGIN-p.r); if (!s.obstacles.some(o=>rectCircleOverlap(p.x,ny,p.r,o))) p.y = ny;

      // shooting
      p.fireCooldown -= dt;
      if (s.mouse.down && p.fireCooldown<=0){
        const dx=s.mouse.x-p.x, dy=s.mouse.y-p.y, d=Math.hypot(dx,dy)||1;
        s.bullets.push({ x:p.x, y:p.y, vx:dx/d*520, vy:dy/d*520, r:3, owner:'player', life:2 });
        const ang=Math.atan2(dy,dx); spawnParticles(p.x+Math.cos(ang)*p.r, p.y+Math.sin(ang)*p.r, '#fff8', 6, 1.6);
        p.flashTimer=0.07; p.fireCooldown=0.15; SFX.shot();
      }

      // bots
      s.bots.forEach(b => {
        b.jitter = (b.jitter||0) + dt*2.2;
        const a0 = Math.atan2(p.y-b.y, p.x-b.x) + Math.sin(b.jitter)*0.25;
        const totalDx = Math.cos(a0)*b.speed*dt, totalDy = Math.sin(a0)*b.speed*dt;
        const steps = Math.max(1, Math.ceil(Math.hypot(totalDx,totalDy) / Math.max(1, b.r*0.6)));
        const stepX=totalDx/steps, stepY=totalDy/steps;
        for (let i=0;i<steps;i++){
          let tx=b.x+stepX, ty=b.y; if(!s.obstacles.some(o=>rectCircleOverlap(tx,b.y,b.r,o))) b.x = clamp(tx, MAP_MARGIN+b.r, W-MAP_MARGIN-b.r);
          ty=b.y+stepY; if(!s.obstacles.some(o=>rectCircleOverlap(b.x,ty,b.r,o))) b.y = clamp(ty, MAP_MARGIN+b.r, H-MAP_MARGIN-b.r);
        }
        b.fireCooldown -= dt;
        if (b.fireCooldown<=0){ const dx=p.x-b.x, dy=p.y-b.y, aa=Math.atan2(dy,dx)+(Math.random()-0.5)*0.18; s.bullets.push({ x:b.x, y:b.y, vx:Math.cos(aa)*360, vy:Math.sin(aa)*360, r:3, owner:'bot', life:2 }); b.fireCooldown = b.shootEvery * Math.max(0.6, 1 - 0.05*(s.level-1)); }
      });

      // bullets
      s.bullets.forEach(b=>{ b.x+=b.vx*dt; b.y+=b.vy*dt; b.life-=dt; });
      s.bullets = s.bullets.filter(b => b.life>0 && b.x>-10 && b.x<W+10 && b.y>-10 && b.y<H+10 && !s.obstacles.some(o=>bulletHitsObstacle(b,o)) );

      // hits (bot bullets -> player)
      s.bullets.forEach(b=>{
        if (b.owner==='bot' && Math.hypot(b.x-p.x,b.y-p.y) < b.r + p.r){ if (p.hitCooldown<=0){ p.hp -= 10; p.hitCooldown = 0.35; spawnParticles(p.x,p.y,'#f00',8,2.2); SFX.hit(); } b.life = 0; }
      });

      // hits (player bullets -> bots)
      s.bots = s.bots.filter(b => {
        let alive = true;
        s.bullets.forEach(proj => {
          if (proj.owner==='player' && Math.hypot(b.x-proj.x,b.y-proj.y) < (b.r+proj.r)){
            b.hp -= 25; proj.life = 0; spawnParticles(b.x,b.y,'#f33',10,2); SFX.hit();
            if (b.hp<=0){ alive=false; s.score++; const over=-b.hp; const extra=20 + Math.min(40, Math.max(0, Math.round(over*1.2))); spawnParticles(b.x,b.y,b.elite?'#ffd372':'#ff7b72', extra, 3); SFX.death(Math.min(1, over/50)); maybeLevelUp(); }
          }
        });
        return alive;
      });

      // touch damage
      s.bots.forEach(b => { if (Math.hypot(b.x-p.x,b.y-p.y) < b.r + p.r){ if (p.hitCooldown<=0){ p.hp -= 10; p.hitCooldown = 0.35; spawnParticles(p.x,p.y,'#f00',8,2.2); SFX.hit(); } } });

      // medkits
      trySpawnMedkit(); s.medkits.forEach(m=> m.timeLeft -= dt);
      s.medkits = s.medkits.filter(m => { if (m.timeLeft<=0) return false; if (Math.hypot(m.x-p.x,m.y-p.y) < m.r + p.r){ p.hp = Math.min(100, p.hp + 30); spawnParticles(m.x,m.y,'#8cff8c',18,2.6); SFX.heal(); return false; } return true; });

      // particles
      s.particles.forEach(pt => { pt.x+=pt.vx*dt; pt.y+=pt.vy*dt; pt.life-=dt; }); s.particles = s.particles.filter(pt => pt.life>0);

      // death
      if (p.hp<=0){ s.mode='gameover'; stopMusic(); try { if (s.score > (s.bestScore||0)) { s.bestScore = s.score; localStorage.setItem('matatudo_best', String(s.bestScore)); } } catch {} }

      // level popup decay
      s.levelUpFlash = Math.max(0, s.levelUpFlash - dt);
    };

    // -------------- Draw --------------
    const drawSoldier = (x,y,ang,r,flash) => {
      const c = s.ctx; c.save(); c.translate(x,y); c.rotate(ang);
      c.fillStyle='rgba(0,0,0,0.25)'; c.beginPath(); c.ellipse(0,r*0.9,r*0.9,r*0.4,0,0,Math.PI*2); c.fill();
      const g=c.createRadialGradient(0,-r*0.2,r*0.2,0,0,r*1.05); g.addColorStop(0,'#34d27a'); g.addColorStop(1,'#228d4e');
      c.fillStyle=g; c.beginPath(); c.arc(0,0,r,0,Math.PI*2); c.fill();
      c.fillStyle='#1e824c'; c.beginPath(); c.arc(0,-r*0.3,r*0.95,Math.PI,0); c.fill();
      c.fillStyle='#145a32'; c.fillRect(-r,-r*0.3,r*2,r*0.15);
      c.fillStyle='#2ecc71'; c.fillRect(-r*1.2,-r*0.4,r*0.4,r*1.2); c.fillRect(r*0.8,-r*0.4,r*0.4,r*1.2);
      c.fillStyle='#dcdcdc'; c.fillRect(0,-3,r+14,6); c.fillStyle='#555'; c.fillRect(r+14,-2,4,4);
      if (flash>0){ c.fillStyle='rgba(255,240,120,0.9)'; c.beginPath(); c.ellipse(r+20,0,7,3.5,0,0,Math.PI*2); c.fill(); }
      c.restore();
    };
    const drawObstacle = (o, alpha=1) => {
      const c=s.ctx; c.save(); c.globalAlpha=alpha; c.fillStyle='#4b5563'; c.fillRect(o.x,o.y,o.w,o.h); c.strokeStyle='rgba(0,0,0,0.25)'; c.strokeRect(o.x+0.5,o.y+0.5,o.w-1,o.h-1); c.fillStyle='rgba(255,255,255,0.08)'; for(let i=0;i<30;i++){ const rx=o.x+4+Math.random()*(o.w-8), ry=o.y+4+Math.random()*(o.h-8); c.fillRect(rx,ry,1,1);} c.restore();
    };
    const draw = () => {
      const c = s.ctx; c.fillStyle = s.groundPattern || '#0b1220'; c.fillRect(0,0,W,H);
      c.strokeStyle='rgba(255,255,255,0.2)'; c.strokeRect(MAP_MARGIN,MAP_MARGIN,W-2*MAP_MARGIN,H-2*MAP_MARGIN);
      s.obstacles.forEach(o=>drawObstacle(o, s.obstacleAlpha));
      s.medkits.forEach(m => { const bl=m.timeLeft<5 ? (Math.floor(m.timeLeft*10)%2===0) : true; if(!bl) return; const r=m.r; c.fillStyle='#e5f7ff'; c.fillRect(m.x-r,m.y-r,r*2,r*2); c.strokeStyle='#94a3b8'; c.strokeRect(m.x-r+0.5,m.y-r+0.5,r*2-1,r*2-1); c.fillStyle='#e11d48'; c.fillRect(m.x-r*0.25,m.y-r*0.8,r*0.5,r*1.6); c.fillRect(m.x-r*0.8,m.y-r*0.25,r*1.6,r*0.5); });
      const p=s.player; const ang=Math.atan2(s.mouse.y-p.y,s.mouse.x-p.x); drawSoldier(p.x,p.y,ang,p.r,p.flashTimer);
      s.bots.forEach(b=>{ c.fillStyle=b.elite?'#f0c420':'#ff7b72'; c.beginPath(); c.arc(b.x,b.y,b.r,0,Math.PI*2); c.fill(); c.strokeStyle='rgba(255,255,255,0.6)'; c.lineWidth=2; c.beginPath(); const frac=Math.max(0,b.hp)/(b.elite?200:40); c.arc(b.x,b.y,b.r+4,-Math.PI/2,-Math.PI/2+frac*Math.PI*2); c.stroke(); });
      s.bullets.forEach(b=>{ c.fillStyle=b.owner==='player'?'#e6ff71':'#ffa8a3'; c.beginPath(); c.arc(b.x,b.y,b.r,0,Math.PI*2); c.fill(); });
      s.particles.forEach(pt=>{ c.fillStyle=pt.color; c.beginPath(); c.arc(pt.x,pt.y,pt.size,0,Math.PI*2); c.fill(); });
      // HUD
      c.fillStyle='#fff'; c.font='14px ui-sans-serif,system-ui'; c.fillText(`Score: ${s.score}`, 12, 20); c.fillText(`HP: ${Math.max(0,p.hp)}`, 12, 40); c.fillText(`Level: ${s.level}`, 12, 60);
      // overlays
      c.textAlign='center';
      if (s.levelUpFlash>0 && Math.floor(s.time*6)%2===0){ c.font='bold 28px ui-sans-serif,system-ui'; c.fillText('Level Up!', W/2, MAP_MARGIN+34); }
      if (s.mode==='intro'){
        c.fillStyle='rgba(0,0,0,0.7)'; c.fillRect(0,0,W,H); c.fillStyle='#fff'; const t=s.time; const alpha = Math.min(1, t/0.5) * (t<1.2?1:Math.max(0,2-t)); c.globalAlpha = alpha; c.font='bold 48px ui-sans-serif,system-ui'; c.fillText('MataTudo', W/2, H/2 - 10); c.globalAlpha = Math.max(0, alpha*0.8); c.font='16px ui-sans-serif,system-ui'; c.fillText('a tiny top-down shooter', W/2, H/2 + 22); c.globalAlpha = 1;
      } else if (s.mode==='menu'){
        c.fillStyle='rgba(0,0,0,0.55)'; c.fillRect(0,0,W,H); c.fillStyle='#fff'; c.font='bold 36px ui-sans-serif,system-ui'; c.fillText('MataTudo', W/2, H/2-60); c.font='16px ui-sans-serif,system-ui'; c.fillText('WASD/Arrows move • Mouse aims • Click shoots', W/2, H/2-20); c.fillText('Click or press any key to start', W/2, H/2+10); c.fillText(`Best: ${s.bestScore}`, W/2, H/2+40); c.font='12px ui-sans-serif,system-ui'; c.fillText('Press M to Mute/Unmute', W/2, H/2+64);
      } else if (s.mode==='countdown'){
        c.fillStyle='rgba(0,0,0,0.35)'; c.fillRect(0,0,W,H); c.fillStyle='#fff'; c.font='bold 48px ui-sans-serif,system-ui'; c.fillText(String(Math.max(1,Math.ceil(s.countdown))), W/2, H/2);
      } else if (s.mode==='gameover'){
        c.fillStyle='rgba(0,0,0,0.6)'; c.fillRect(0,0,W,H); c.fillStyle='#fff'; c.font='bold 28px ui-sans-serif,system-ui'; c.fillText('Game Over', W/2, H/2-20); c.font='16px ui-sans-serif,system-ui'; c.fillText(`Score: ${s.score}   Best: ${s.bestScore}`, W/2, H/2+10); c.fillText('Press R or click to restart', W/2, H/2+36);
      }
      c.textAlign='start';
    };

    // -------------- Input --------------
    const toLocalCoords = (e) => { const r = canvas.getBoundingClientRect(); s.mouse.x = (e.clientX - r.left) * (W / r.width); s.mouse.y = (e.clientY - r.top) * (H / r.height); };
    const onMouseMove = (e) => toLocalCoords(e);
    const onMouseDown = (e) => { s.mouse.down=true; toLocalCoords(e); if (s.mode==='intro'){ s.mode='menu'; stopMusic(); return; } if (s.mode==='menu' || s.mode==='gameover'){ startGame(); } };
    const onMouseUp = () => { s.mouse.down=false; };
    const onKeyDown = (e) => { const k=e.key.toLowerCase(); if (!e.repeat) s.keys[k]=true; if (k==='m'){ setMuted(m=>!m); setMasterVolume(!muted?0:volume); return; } if (s.mode==='intro'){ s.mode='menu'; stopMusic(); return; } if (s.mode==='menu'){ startGame(); return; } if (s.mode==='gameover' && k==='r'){ startGame(); return; } };
    const onKeyUp = (e) => { s.keys[e.key.toLowerCase()] = false; };

    window.addEventListener('mousemove', onMouseMove);
    window.addEventListener('mousedown', onMouseDown);
    window.addEventListener('mouseup', onMouseUp);
    window.addEventListener('keydown', onKeyDown);
    window.addEventListener('keyup', onKeyUp);

    // -------------- Main loop --------------
    setMounted(true);
    const step = (t) => {
      if (!s.lastTime) s.lastTime = t;
      const dt = Math.min(0.033, (t - s.lastTime) / 1000); s.lastTime = t;
      update(dt); draw();
      rafRef.current = requestAnimationFrame(step);
    };
    rafRef.current = requestAnimationFrame(step);

    return () => {
      cancelAnimationFrame(rafRef.current);
      window.removeEventListener('mousemove', onMouseMove);
      window.removeEventListener('mousedown', onMouseDown);
      window.removeEventListener('mouseup', onMouseUp);
      window.removeEventListener('keydown', onKeyDown);
      window.removeEventListener('keyup', onKeyUp);
      if (s.audio?.musicEl) { s.audio.musicEl.pause(); }
    };
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, [running]);

  return (
    <div className="w-full h-full flex flex-col items-center gap-3 py-4">
      <h1 className="text-xl font-semibold">MataTudo — Alpha 5</h1>
      {!mounted && <div className="text-sm opacity-80">Loading…</div>}
      <canvas ref={canvasRef} width={W} height={H} className="rounded-2xl shadow-lg border border-white/10 bg-black" />
      <div className="flex flex-wrap gap-3 items-center">
        <button className="px-3 py-1 rounded-xl border border-white/20 hover:border-white/60" onClick={() => setRunning(r=>!r)}>{running? 'Pause':'Resume'}</button>
        <button className="px-3 py-1 rounded-xl border border-white/20 hover:border-white/60" onClick={() => setMuted(m=>!m)}>{muted? 'Unmute':'Mute'}</button>
        <label className="text-sm opacity-90 flex items-center gap-2">Vol
          <input type="range" min={0} max={1} step={0.05} value={volume} onChange={(e)=>setVolume(parseFloat(e.target.value))} className="w-32" />
          <span className="w-8 text-right">{Math.round(volume*100)}</span>
        </label>
      </div>
      <div className="text-xs opacity-70">WASD/Arrows move • Mouse aims • Click shoots • Any Key/Click starts • R restarts • M mutes</div>
    </div>
  );
}
>
