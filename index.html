<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>MataTudo — Alpha 5</title>
<style>
  :root { color-scheme: dark; }
  html, body { height: 100%; margin: 0; background:#0b1220; color:#fff; font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif;}
  .wrap { min-height: 100%; display:grid; place-items:center; padding:20px; }
  .panel { display:flex; flex-direction:column; gap:10px; align-items:center; }
  canvas { background:#000; border-radius:16px; border:1px solid rgba(255,255,255,.08); box-shadow:0 10px 30px rgba(0,0,0,.35); }
  .row { display:flex; gap:10px; align-items:center; flex-wrap:wrap; }
  .btn { padding:6px 10px; border-radius:10px; border:1px solid rgba(255,255,255,.2); background:transparent; color:#fff; cursor:pointer; }
  .btn:hover { border-color: rgba(255,255,255,.6); }
  .hint { font-size:12px; opacity:.8 }
  input[type="range"]{ width:120px; }
  .title { font-weight:700; font-size:18px; letter-spacing:.2px; }
</style>
</head>
<body>
<div class="wrap">
  <div class="panel">
    <div class="title">MataTudo — Alpha 5</div>
    <canvas id="game" width="900" height="560"></canvas>
    <div class="row">
      <button id="pause" class="btn">Pause</button>
      <button id="mute" class="btn">Mute</button>
      <label>Vol <input id="vol" type="range" min="0" max="1" step="0.05" value="0.7"></label>
    </div>
    <div class="hint">WASD/Arrows move • Mouse aims • Click shoots • Any Key/Click starts • R restarts • M mutes</div>
  </div>
</div>

<script>
(() => {
  // ---------- Config ----------
  const W = 900, H = 560, MAP_MARGIN = 12;
  const LEVEL_KILLS = 50; // kills per level
  const MUSIC_URL = window.MT_TRACK_URL || "https://raw.githubusercontent.com/esteves7771/MataTudo/main/retro-synthwave-gaming-music-270173.mp3";

  // ---------- DOM ----------
  const cvs = document.getElementById('game');
  const ctx = cvs.getContext('2d', { alpha:false });
  const btnPause = document.getElementById('pause');
  const btnMute = document.getElementById('mute');
  const vol = document.getElementById('vol');

  // ---------- Helpers ----------
  const clamp = (v, a, b) => Math.max(a, Math.min(b, v));
  const rectOverAny = (rect, arr) => arr.some(o => !(rect.x + rect.w < o.x || rect.x > o.x + o.w || rect.y + rect.h < o.y || rect.y > o.y + o.h));
  const rectCircleOverlap = (cx, cy, r, o) => {
    const nx = clamp(cx, o.x, o.x + o.w), ny = clamp(cy, o.y, o.y + o.h);
    const dx = cx - nx, dy = cy - ny; return dx*dx + dy*dy <= r*r;
  };
  const bulletHitsObstacle = (b, o) =>
    (b.x + b.r > o.x && b.x - b.r < o.x + o.w && b.y + b.r > o.y && b.y - b.r < o.y + o.h);
  const posIsFree = (x, y, r, s) => {
    if (x < MAP_MARGIN + r || x > W - MAP_MARGIN - r || y < MAP_MARGIN + r || y > H - MAP_MARGIN - r) return false;
    if (rectOverAny({ x: x - r, y: y - r, w: r*2, h: r*2 }, s.obstacles)) return false;
    if (Math.hypot(x - s.player.x, y - s.player.y) < 80) return false;
    return true;
  };

  // ---------- Audio (SFX via WebAudio, Music via HTMLAudio) ----------
  const audio = { ctx:null, master:null, sfxGain:null, muted:false, music:null };
  function ensureAC() {
    if (audio.muted) return;
    if (!audio.ctx) {
      const AC = window.AudioContext || window.webkitAudioContext;
      if (!AC) return;
      const ac = new AC();
      const master = ac.createGain(); master.gain.value = parseFloat(vol.value); master.connect(ac.destination);
      const sfxGain = ac.createGain(); sfxGain.gain.value = 1.0; sfxGain.connect(master);
      audio.ctx = ac; audio.master = master; audio.sfxGain = sfxGain;
    } else if (audio.ctx.state === 'suspended') {
      audio.ctx.resume();
    }
  }
  function setVolume(x){ if (audio.master) audio.master.gain.value = x; if (audio.music) audio.music.volume = audio.muted ? 0 : x; }
  function toggleMute(){ audio.muted = !audio.muted; btnMute.textContent = audio.muted ? "Unmute" : "Mute"; setVolume(audio.muted ? 0 : parseFloat(vol.value)); if (audio.muted && audio.music) audio.music.pause(); }
  vol.addEventListener('input', () => setVolume(parseFloat(vol.value)));
  btnMute.addEventListener('click', toggleMute);
  document.addEventListener('keydown', e => { if (e.key.toLowerCase() === 'm') toggleMute(); });

  function quickBeep(freq=800, dur=0.06, type='square', gain=0.03){
    if (audio.muted) return; ensureAC(); if (!audio.ctx) return;
    const ac = audio.ctx, osc = ac.createOscillator(), g = ac.createGain();
    osc.type = type; osc.frequency.value = freq; g.gain.value = gain;
    osc.connect(g).connect(audio.sfxGain);
    const now = ac.currentTime; g.gain.setValueAtTime(gain,now); g.gain.exponentialRampToValueAtTime(0.0001,now+dur);
    osc.start(now); osc.stop(now+dur);
  }
  function noiseBurst(dur=0.25, gain=0.05){
    if (audio.muted) return; ensureAC(); if (!audio.ctx) return;
    const ac = audio.ctx, buf = ac.createBuffer(1,ac.sampleRate*dur,ac.sampleRate), data = buf.getChannelData(0);
    for (let i=0;i<data.length;i++) data[i]=(Math.random()*2-1)*0.6;
    const src = ac.createBufferSource(); src.buffer = buf; const g = ac.createGain(); g.gain.value = gain; const lp = ac.createBiquadFilter(); lp.type='lowpass'; lp.frequency.value=1200;
    src.connect(lp).connect(g).connect(audio.sfxGain);
    const now=ac.currentTime; g.gain.setValueAtTime(gain,now); g.gain.exponentialRampToValueAtTime(0.0001,now+dur);
    src.start(now);
  }
  const SFX = {
    shot: () => quickBeep(1100,0.045,'square',0.03),
    hit:  () => quickBeep(280, 0.06,'sine',0.02),
    heal: () => quickBeep(900, 0.12,'triangle',0.035),
    death:(i=0.4)=>{ noiseBurst(0.22+0.15*i,0.04+0.06*i); quickBeep(200,0.3+0.15*i,'sawtooth',0.02+0.04*i); },
  };

  function startMusic(){
    if (!audio.music) {
      audio.music = new Audio(MUSIC_URL);
      audio.music.loop = true;
      audio.music.crossOrigin = 'anonymous';
      audio.music.preload = 'auto';
    }
    if (!audio.muted) { audio.music.volume = parseFloat(vol.value); audio.music.play().catch(()=>{}); }
  }
  function stopMusic(){ if (audio.music) { audio.music.pause(); audio.music.currentTime = 0; } }

  // ---------- State ----------
  const s = {
    time:0, lastTime:0, running:true,
    mode:'intro', introTime:0, countdown:2,
    level:1, levelUpFlash:0,
    score:0, bestScore:0,
    lastMedkitAtScore:0, lastEliteAtScore:0,
    player:{ x:W/2, y:H/2, r:12, speed:240, hp:100, fireCooldown:0, flashTimer:0, hitCooldown:0 },
    keys:{}, mouse:{ x:W/2, y:H/2, down:false },
    bullets:[], bots:[], particles:[], medkits:[],
    groundPattern:null,
    spawnTimer:0, firstWaveRemaining:4, firstWaveInterval:0.4, firstWaveTimer:0.4,
    // obstacles & fading
    obstacles:[
      { x:280,y:180,w:90,h:90 },
      { x:610,y:340,w:120,h:70 },
      { x:440,y: 90,w:70,h:70 },
      { x:120,y:400,w:140,h:40 },
    ],
    obstacleAlpha:1, obstaclePhase:'stable', obstacleFadeT:0
  };
  try { const saved = localStorage.getItem('matatudo_best'); if (saved) s.bestScore = parseInt(saved, 10) || 0; } catch {}

  // Pattern
  (function(){
    const pc = document.createElement('canvas'); pc.width=64; pc.height=64;
    const pg = pc.getContext('2d');
    pg.fillStyle='#27303a'; pg.fillRect(0,0,64,64);
    for (let i=0;i<140;i++){ pg.fillStyle=`rgba(255,255,255,${0.06+Math.random()*0.06})`; pg.fillRect(Math.random()*64, Math.random()*64, 1, 1); }
    pg.strokeStyle='rgba(0,0,0,0.12)';
    for (let x=0;x<=64;x+=16){ pg.beginPath(); pg.moveTo(x,0); pg.lineTo(x,64); pg.stroke(); }
    for (let y=0;y<=64;y+=16){ pg.beginPath(); pg.moveTo(0,y); pg.lineTo(64,y); pg.stroke(); }
    s.groundPattern = ctx.createPattern(pc,'repeat');
  })();

  // ---------- Obstacles regen ----------
  function randomObstacles() {
    const count = 4 + Math.floor(Math.random()*3); // 4-6
    const obs = [];
    for (let i=0;i<count;i++){
      const t = Math.random();
      if (t < 0.33) {
        const w=60+Math.random()*120, h=60+Math.random()*120;
        const x=MAP_MARGIN+20+Math.random()*(W-2*(MAP_MARGIN+20)-w);
        const y=MAP_MARGIN+20+Math.random()*(H-2*(MAP_MARGIN+20)-h);
        obs.push({x,y,w,h});
      } else if (t < 0.66) {
        const w=160+Math.random()*160, h=30+Math.random()*50;
        const x=MAP_MARGIN+20+Math.random()*(W-2*(MAP_MARGIN+20)-w);
        const y=MAP_MARGIN+20+Math.random()*(H-2*(MAP_MARGIN+20)-h);
        obs.push({x,y,w,h});
      } else {
        const cx=MAP_MARGIN+80+Math.random()*(W-2*(MAP_MARGIN+80));
        const cy=MAP_MARGIN+60+Math.random()*(H-2*(MAP_MARGIN+60));
        const n = 3 + Math.floor(Math.random()*4);
        for (let j=0;j<n;j++){
          const w=40+Math.random()*60, h=40+Math.random()*60;
          const x=clamp(cx+(Math.random()*120-60), MAP_MARGIN+10, W-MAP_MARGIN-10-w);
          const y=clamp(cy+(Math.random()*100-50), MAP_MARGIN+10, H-MAP_MARGIN-10-h);
          obs.push({x,y,w,h});
        }
      }
    }
    // keep player zone clear; if not, fallback to previous
    const safe = { x:s.player.x-80, y:s.player.y-80, w:160, h:160 };
    const safeOverlap = obs.some(o => !(safe.x + safe.w < o.x || safe.x > o.x + o.w || safe.y + safe.h < o.y || safe.y > o.y + o.h));
    return safeOverlap ? s.obstacles : obs;
  }
  function triggerObstacleSwap(){ s.obstaclePhase='fadeOut'; s.obstacleFadeT=0; }
  function updateObstacleFade(dt){
    if (s.obstaclePhase==='stable') return;
    const DUR = 0.45;
    s.obstacleFadeT += dt;
    const t = clamp(s.obstacleFadeT / DUR, 0, 1);
    if (s.obstaclePhase==='fadeOut'){
      s.obstacleAlpha = 1 - t;
      if (s.obstacleFadeT >= DUR){ s.obstacles = randomObstacles(); s.obstaclePhase='fadeIn'; s.obstacleFadeT = 0; }
    } else {
      s.obstacleAlpha = t;
      if (s.obstacleFadeT >= DUR){ s.obstaclePhase='stable'; s.obstacleAlpha=1; }
    }
  }

  // ---------- Spawners ----------
  function spawnParticles(x,y,color,count,size=2){
    for (let i=0;i<count;i++){
      const a = Math.random()*Math.PI*2, v=40+Math.random()*80;
      s.particles.push({ x,y, vx:Math.cos(a)*v, vy:Math.sin(a)*v, life:0.4+Math.random()*0.4, color, size });
    }
  }
  function spawnBot(elite=false){
    let tries=0, x=0, y=0, r=elite?16:12;
    while (tries++<40){
      const edge=Math.floor(Math.random()*4);
      if (edge===0){ x = MAP_MARGIN + r + 2; y = Math.random()*(H-2*MAP_MARGIN)+MAP_MARGIN; }
      else if (edge===1){ x = W - MAP_MARGIN - r - 2; y = Math.random()*(H-2*MAP_MARGIN)+MAP_MARGIN; }
      else if (edge===2){ x = Math.random()*(W-2*MAP_MARGIN)+MAP_MARGIN; y = MAP_MARGIN + r + 2; }
      else { x = Math.random()*(W-2*MAP_MARGIN)+MAP_MARGIN; y = H - MAP_MARGIN - r - 2; }
      if (posIsFree(x,y,r,s)) break;
    }
    const base = 80+Math.random()*35;
    const hp = elite?200:40;
    const speed = base * (1 + 0.08*(s.level-1)) * (elite?0.9:1);
    const shootEvery = (0.9 + Math.random()*0.9) * (elite?0.85:1);
    s.bots.push({ x,y,r,speed,hp,fireCooldown:0,shootEvery,jitter:Math.random()*Math.PI*2, elite });
  }
  function trySpawnMedkit(){
    if (s.score>0 && s.score%30===0 && s.lastMedkitAtScore!==s.score){
      for (let i=0;i<60;i++){
        const r=10; const x=MAP_MARGIN+r + Math.random()*(W-2*(MAP_MARGIN+r)); const y=MAP_MARGIN+r + Math.random()*(H-2*(MAP_MARGIN+r));
        if (!posIsFree(x,y,r,s)) continue;
        s.medkits.push({ x,y,r,timeLeft:20 }); s.lastMedkitAtScore = s.score; break;
      }
    }
  }

  // ---------- Leveling ----------
  function maybeLevelUp(){
    const nextLevel = Math.floor(s.score / LEVEL_KILLS) + 1;
    if (nextLevel > s.level){
      s.level = nextLevel;
      s.levelUpFlash = 2; // seconds
      triggerObstacleSwap();
    }
  }

  // ---------- Start/Reset ----------
  function startGame(){
    ensureAC(); startMusic();
    s.player = { x:W/2, y:H/2, r:12, speed:240, hp:100, fireCooldown:0, flashTimer:0, hitCooldown:0 };
    s.bullets=[]; s.bots=[]; s.particles=[]; s.medkits=[];
    s.spawnTimer=0; s.score=0; s.lastEliteAtScore=0; s.lastMedkitAtScore=0;
    s.firstWaveRemaining=4; s.firstWaveTimer=s.firstWaveInterval;
    s.level=1; s.levelUpFlash=0; s.obstaclePhase='stable'; s.obstacleAlpha=1;
    s.mode='countdown'; s.countdown=2;
  }

  // ---------- Update ----------
  function update(dt){
    s.time += dt;
    updateObstacleFade(dt);

    if (!s.running) return;

    // states
    if (s.mode==='intro'){ s.introTime += dt; if (s.introTime>1.6){ s.mode='menu'; stopMusic(); } return; }
    if (s.mode==='menu') return;
    if (s.mode==='countdown'){ s.countdown -= dt; if (s.countdown<=0){ s.mode='playing'; } return; }
    if (s.mode!=='playing') return;

    // spawn rate scales by level
    s.spawnTimer -= dt;
    const spawnBase = Math.max(0.5, 1.6 - Math.min(60, s.score/5)*0.01);
    const spawnScaled = Math.max(0.25, spawnBase * (1 - 0.06*(s.level-1)));
    if (s.spawnTimer<=0){
      const eliteChance = Math.min(0.5, 0.05*s.level); // rising chance
      spawnBot(Math.random() < eliteChance);
      s.spawnTimer = spawnScaled;
    }
    if (s.firstWaveRemaining>0){
      s.firstWaveTimer -= dt;
      if (s.firstWaveTimer<=0){ spawnBot(false); s.firstWaveRemaining--; s.firstWaveTimer = s.firstWaveInterval; }
    }
    if (s.score>0 && s.score%20===0 && s.lastEliteAtScore !== s.score){ spawnBot(true); s.lastEliteAtScore = s.score; }

    // player move
    const p = s.player;
    p.hitCooldown = Math.max(0, p.hitCooldown - dt);
    p.flashTimer = Math.max(0, p.flashTimer - dt);
    let ix=0, iy=0;
    if (s.keys['w']||s.keys['arrowup']) iy--;
    if (s.keys['s']||s.keys['arrowdown']) iy++;
    if (s.keys['a']||s.keys['arrowleft']) ix--;
    if (s.keys['d']||s.keys['arrowright']) ix++;
    const mag = Math.hypot(ix,iy) || 1;
    const mvx = ix/mag * p.speed * dt, mvy = iy/mag * p.speed * dt;
    let nx = clamp(p.x + mvx, MAP_MARGIN+p.r, W-MAP_MARGIN-p.r); if (!s.obstacles.some(o=>rectCircleOverlap(nx,p.y,p.r,o))) p.x = nx;
    let ny = clamp(p.y + mvy, MAP_MARGIN+p.r, H-MAP_MARGIN-p.r); if (!s.obstacles.some(o=>rectCircleOverlap(p.x,ny,p.r,o))) p.y = ny;

    // shooting
    p.fireCooldown -= dt;
    if (s.mouse.down && p.fireCooldown<=0){
      const dx = s.mouse.x - p.x, dy = s.mouse.y - p.y, d = Math.hypot(dx,dy) || 1;
      s.bullets.push({ x:p.x, y:p.y, vx:dx/d*520, vy:dy/d*520, r:3, owner:'player', life:2 });
      const ang = Math.atan2(dy,dx); spawnParticles(p.x+Math.cos(ang)*p.r, p.y+Math.sin(ang)*p.r, '#fff8', 6, 1.6);
      p.flashTimer = 0.07; p.fireCooldown = 0.15; SFX.shot();
    }

    // bots
    s.bots.forEach(b => {
      b.jitter = (b.jitter || 0) + dt*2.2;
      const a0 = Math.atan2(p.y-b.y, p.x-b.x) + Math.sin(b.jitter)*0.25;
      const totalDx = Math.cos(a0)*b.speed*dt, totalDy = Math.sin(a0)*b.speed*dt;
      const steps = Math.max(1, Math.ceil(Math.hypot(totalDx,totalDy) / Math.max(1, b.r*0.6)));
      const stepX=totalDx/steps, stepY=totalDy/steps;
      for (let i=0;i<steps;i++){
        let tx = b.x + stepX, ty = b.y;
        if (!s.obstacles.some(o=>rectCircleOverlap(tx,b.y,b.r,o))) b.x = clamp(tx, MAP_MARGIN+b.r, W-MAP_MARGIN-b.r);
        ty = b.y + stepY;
        if (!s.obstacles.some(o=>rectCircleOverlap(b.x,ty,b.r,o))) b.y = clamp(ty, MAP_MARGIN+b.r, H-MAP_MARGIN-b.r);
      }
      b.fireCooldown -= dt;
      if (b.fireCooldown<=0){
        const dx=p.x-b.x, dy=p.y-b.y, aa = Math.atan2(dy,dx) + (Math.random()-0.5)*0.18;
        s.bullets.push({ x:b.x, y:b.y, vx:Math.cos(aa)*360, vy:Math.sin(aa)*360, r:3, owner:'bot', life:2 });
        b.fireCooldown = b.shootEvery * Math.max(0.6, 1 - 0.05*(s.level-1));
      }
    });

    // bullets
    s.bullets.forEach(b => { b.x += b.vx*dt; b.y += b.vy*dt; b.life-=dt; });
    s.bullets = s.bullets.filter(b => b.life>0 && b.x>-10 && b.x<W+10 && b.y>-10 && b.y<H+10 && !s.obstacles.some(o=>bulletHitsObstacle(b,o)) );

    // hits (bot bullets -> player)
    s.bullets.forEach(b => {
      if (b.owner==='bot' && Math.hypot(b.x-p.x,b.y-p.y) < b.r + p.r){
        if (p.hitCooldown<=0){ p.hp -= 10; p.hitCooldown = 0.35; spawnParticles(p.x,p.y,'#f00',8,2.2); SFX.hit(); }
        b.life = 0;
      }
    });

    // hits (player bullets -> bots)
    s.bots = s.bots.filter(b => {
      let alive = true;
      s.bullets.forEach(proj => {
        if (proj.owner==='player' && Math.hypot(b.x-proj.x,b.y-proj.y) < (b.r+proj.r)){
          b.hp -= 25; proj.life = 0; spawnParticles(b.x,b.y,'#f33',10,2); SFX.hit();
          if (b.hp<=0){
            alive = false; s.score++;
            const over = -b.hp; const extra = 20 + Math.min(40, Math.max(0, Math.round(over*1.2)));
            spawnParticles(b.x,b.y,b.elite?'#ffd372':'#ff7b72', extra, 3); SFX.death(Math.min(1, over/50));
            maybeLevelUp();
          }
        }
      });
      return alive;
    });

    // touch damage
    s.bots.forEach(b => {
      if (Math.hypot(b.x-p.x,b.y-p.y) < b.r + p.r){
        if (p.hitCooldown<=0){ p.hp -= 10; p.hitCooldown = 0.35; spawnParticles(p.x,p.y,'#f00',8,2.2); SFX.hit(); }
      }
    });

    // medkits
    trySpawnMedkit();
    s.medkits.forEach(m => m.timeLeft -= dt);
    s.medkits = s.medkits.filter(m => {
      if (m.timeLeft<=0) return false;
      if (Math.hypot(m.x-p.x,m.y-p.y) < m.r + p.r){ p.hp = Math.min(100, p.hp + 30); spawnParticles(m.x,m.y,'#8cff8c',18,2.6); SFX.heal(); return false; }
      return true;
    });

    // particles
    s.particles.forEach(pt => { pt.x+=pt.vx*dt; pt.y+=pt.vy*dt; pt.life-=dt; });
    s.particles = s.particles.filter(pt => pt.life>0);

    // death
    if (p.hp<=0){
      s.mode='gameover'; stopMusic();
      try { if (s.score > (s.bestScore||0)) { s.bestScore = s.score; localStorage.setItem('matatudo_best', String(s.bestScore)); } } catch {}
    }

    // level popup timer
    s.levelUpFlash = Math.max(0, s.levelUpFlash - dt);
  }

  // ---------- Draw ----------
  function drawSoldier(x,y,ang,r,flash){
    ctx.save(); ctx.translate(x,y); ctx.rotate(ang);
    ctx.fillStyle='rgba(0,0,0,0.25)'; ctx.beginPath(); ctx.ellipse(0,r*0.9,r*0.9,r*0.4,0,0,Math.PI*2); ctx.fill();
    const g=ctx.createRadialGradient(0,-r*0.2,r*0.2,0,0,r*1.05); g.addColorStop(0,'#34d27a'); g.addColorStop(1,'#228d4e');
    ctx.fillStyle=g; ctx.beginPath(); ctx.arc(0,0,r,0,Math.PI*2); ctx.fill();
    ctx.fillStyle='#1e824c'; ctx.beginPath(); ctx.arc(0,-r*0.3,r*0.95,Math.PI,0); ctx.fill();
    ctx.fillStyle='#145a32'; ctx.fillRect(-r,-r*0.3,r*2,r*0.15);
    ctx.fillStyle='#2ecc71'; ctx.fillRect(-r*1.2,-r*0.4,r*0.4,r*1.2); ctx.fillRect(r*0.8,-r*0.4,r*0.4,r*1.2);
    ctx.fillStyle='#dcdcdc'; ctx.fillRect(0,-3,r+14,6);
    ctx.fillStyle='#555'; ctx.fillRect(r+14,-2,4,4);
    if (flash>0){ ctx.fillStyle='rgba(255,240,120,0.9)'; ctx.beginPath(); ctx.ellipse(r+20,0,7,3.5,0,0,Math.PI*2); ctx.fill(); }
    ctx.restore();
  }
  function drawObstacle(o, alpha=1){
    ctx.save(); ctx.globalAlpha = alpha;
    ctx.fillStyle='#4b5563'; ctx.fillRect(o.x,o.y,o.w,o.h);
    ctx.strokeStyle='rgba(0,0,0,0.25)'; ctx.strokeRect(o.x+0.5,o.y+0.5,o.w-1,o.h-1);
    ctx.fillStyle='rgba(255,255,255,0.08)';
    for (let i=0;i<30;i++){ const rx=o.x+4+Math.random()*(o.w-8), ry=o.y+4+Math.random()*(o.h-8); ctx.fillRect(rx,ry,1,1); }
    ctx.restore();
  }
  function draw(){
    ctx.fillStyle = s.groundPattern || '#0b1220'; ctx.fillRect(0,0,W,H);
    ctx.strokeStyle='rgba(255,255,255,0.2)'; ctx.strokeRect(MAP_MARGIN,MAP_MARGIN,W-2*MAP_MARGIN,H-2*MAP_MARGIN);
    s.obstacles.forEach(o=>drawObstacle(o, s.obstacleAlpha));
    s.medkits.forEach(m => {
      const bl = m.timeLeft<5 ? (Math.floor(m.timeLeft*10)%2===0) : true;
      if (!bl) return; const r=m.r;
      ctx.fillStyle='#e5f7ff'; ctx.fillRect(m.x-r,m.y-r,r*2,r*2);
      ctx.strokeStyle='#94a3b8'; ctx.strokeRect(m.x-r+0.5,m.y-r+0.5,r*2-1,r*2-1);
      ctx.fillStyle='#e11d48'; ctx.fillRect(m.x-r*0.25,m.y-r*0.8,r*0.5,r*1.6); ctx.fillRect(m.x-r*0.8,m.y-r*0.25,r*1.6,r*0.5);
    });
    const p = s.player; const ang = Math.atan2(s.mouse.y-p.y,s.mouse.x-p.x); drawSoldier(p.x,p.y,ang,p.r,p.flashTimer);
    s.bots.forEach(b=>{
      ctx.fillStyle=b.elite?'#f0c420':'#ff7b72'; ctx.beginPath(); ctx.arc(b.x,b.y,b.r,0,Math.PI*2); ctx.fill();
      ctx.strokeStyle='rgba(255,255,255,0.6)'; ctx.lineWidth=2; ctx.beginPath(); const frac=Math.max(0,b.hp)/(b.elite?200:40); ctx.arc(b.x,b.y,b.r+4,-Math.PI/2,-Math.PI/2+frac*Math.PI*2); ctx.stroke();
    });
    s.bullets.forEach(b=>{ ctx.fillStyle = b.owner==='player'?'#e6ff71':'#ffa8a3'; ctx.beginPath(); ctx.arc(b.x,b.y,b.r,0,Math.PI*2); ctx.fill(); });
    s.particles.forEach(pt=>{ ctx.fillStyle=pt.color; ctx.beginPath(); ctx.arc(pt.x,pt.y,pt.size,0,Math.PI*2); ctx.fill(); });

    // HUD
    ctx.fillStyle='#fff'; ctx.font='14px ui-sans-serif,system-ui';
    ctx.fillText(`Score: ${s.score}`, 12, 20);
    ctx.fillText(`HP: ${Math.max(0,s.player.hp)}`, 12, 40);
    ctx.fillText(`Level: ${s.level}`, 12, 60);

    // overlays
    ctx.textAlign='center';
    if (s.levelUpFlash > 0 && Math.floor(s.time*6)%2===0){
      ctx.font='bold 28px ui-sans-serif,system-ui'; ctx.fillText('Level Up!', W/2, MAP_MARGIN + 34);
    }
    if (s.mode==='intro'){
      ctx.fillStyle='rgba(0,0,0,0.7)'; ctx.fillRect(0,0,W,H);
      ctx.fillStyle='#fff'; const t=s.time; const alpha = Math.min(1, t/0.5) * (t<1.2?1:Math.max(0,2-t));
      ctx.globalAlpha = alpha; ctx.font='bold 48px ui-sans-serif,system-ui'; ctx.fillText('MataTudo', W/2, H/2 - 10);
      ctx.globalAlpha = Math.max(0, alpha*0.8); ctx.font='16px ui-sans-serif,system-ui'; ctx.fillText('a tiny top-down shooter', W/2, H/2 + 22); ctx.globalAlpha = 1;
    } else if (s.mode==='menu'){
      ctx.fillStyle='rgba(0,0,0,0.55)'; ctx.fillRect(0,0,W,H);
      ctx.fillStyle='#fff'; ctx.font='bold 36px ui-sans-serif,system-ui'; ctx.fillText('MataTudo', W/2, H/2-60);
      ctx.font='16px ui-sans-serif,system-ui'; ctx.fillText('WASD/Arrows move • Mouse aims • Click shoots', W/2, H/2-20);
      ctx.fillText('Click or press any key to start', W/2, H/2+10);
      ctx.fillText(`Best: ${s.bestScore}`, W/2, H/2+40);
      ctx.font='12px ui-sans-serif,system-ui'; ctx.fillText('Press M to Mute/Unmute', W/2, H/2+64);
    } else if (s.mode==='countdown'){
      ctx.fillStyle='rgba(0,0,0,0.35)'; ctx.fillRect(0,0,W,H);
      ctx.fillStyle='#fff'; ctx.font='bold 48px ui-sans-serif,system-ui'; ctx.fillText(String(Math.max(1,Math.ceil(s.countdown))), W/2, H/2);
    } else if (s.mode==='gameover'){
      ctx.fillStyle='rgba(0,0,0,0.6)'; ctx.fillRect(0,0,W,H);
      ctx.fillStyle='#fff'; ctx.font='bold 28px ui-sans-serif,system-ui'; ctx.fillText('Game Over', W/2, H/2-20);
      ctx.font='16px ui-sans-serif,system-ui'; ctx.fillText(`Score: ${s.score}   Best: ${s.bestScore}`, W/2, H/2+10);
      ctx.fillText('Press R or click to restart', W/2, H/2+36);
    }
    ctx.textAlign='start';
  }

  // ---------- Input ----------
  function toLocalCoords(e){
    const r = cvs.getBoundingClientRect();
    s.mouse.x = (e.clientX - r.left) * (W / r.width);
    s.mouse.y = (e.clientY - r.top) * (H / r.height);
  }
  window.addEventListener('mousemove', toLocalCoords);
  window.addEventListener('mousedown', e => {
    s.mouse.down = true; toLocalCoords(e);
    if (s.mode==='intro'){ s.mode='menu'; stopMusic(); return; }
    if (s.mode==='menu' || s.mode==='gameover'){ startGame(); }
  });
  window.addEventListener('mouseup', () => s.mouse.down = false);
  window.addEventListener('keydown', e => {
    const k = e.key.toLowerCase();
    if (!e.repeat) s.keys[k] = true;
    if (k==='m'){ toggleMute(); return; }
    if (s.mode==='intro'){ s.mode='menu'; stopMusic(); return; }
    if (s.mode==='menu'){ startGame(); return; }
    if (s.mode==='gameover' && k==='r'){ startGame(); return; }
  });
  window.addEventListener('keyup', e => { s.keys[e.key.toLowerCase()] = false; });

  // Pause button
  btnPause.addEventListener('click', () => {
    s.running = !s.running;
    btnPause.textContent = s.running ? 'Pause' : 'Resume';
  });

  // ---------- Loop ----------
  let raf;
  function step(t){
    if (!s.lastTime) s.lastTime = t;
    const dt = Math.min(0.033, (t - s.lastTime) / 1000);
    s.lastTime = t;
    update(dt);
    draw();
    raf = requestAnimationFrame(step);
  }
  raf = requestAnimationFrame(step);

  // ---------- Clean up on unload ----------
  window.addEventListener('beforeunload', () => { cancelAnimationFrame(raf); stopMusic(); });

})();
</script>
</body>
</html>
