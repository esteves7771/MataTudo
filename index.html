<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>MataTudo — Alpha 13</title>
<style>
  :root { color-scheme: dark; }
  html,body { height:100%; margin:0; background:#0b1220; color:#e8f0ff; font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif; }
  .shell { min-height:100%; display:flex; gap:22px; align-items:center; justify-content:center; padding:18px; }
  .sidebar {
    width:220px; min-height:708px; border-radius:14px;
    background: #0c1528; border:1px solid rgba(255,255,255,.08);
    box-shadow:0 8px 28px rgba(0,0,0,.35); padding:14px 12px;
  }
  .sb-title { font-weight:800; letter-spacing:.6px; margin-bottom:12px; text-shadow:0 2px 0 rgba(0,0,0,.35); }
  .sb-card { background:#0b1220; border:1px solid rgba(255,255,255,.07); border-radius:10px; padding:10px; margin-bottom:12px; }
  .mono { font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, "Liberation Mono", monospace; }
  .hpbar { height:10px; background:#121a2f; border-radius:8px; border:1px solid rgba(255,255,255,.08); overflow:hidden; }
  .hpfill { height:100%; background:linear-gradient(90deg,#2af598,#08a88a); width:100%; }
  .mini { font-size:12px; opacity:.9 }
  .row { display:flex; align-items:center; justify-content:space-between; gap:8px; }
  .hudnum { font-weight:700; }
  canvas { background:#000; border-radius:16px; border:1px solid rgba(255,255,255,.08); box-shadow:0 10px 30px rgba(0,0,0,.35); }
  .controls { margin-top:10px; display:flex; gap:10px; align-items:center; flex-wrap:wrap; }
  .btn { padding:6px 10px; border-radius:10px; border:1px solid rgba(255,255,255,.2); background:transparent; color:#fff; cursor:pointer; }
  .btn:hover { border-color: rgba(255,255,255,.6); }
  input[type="range"]{ width:120px; }
  .title { grid-column:1/-1; font-weight:800; font-size:18px; letter-spacing:.2px; text-align:center; margin-bottom:6px; }
  .hint { font-size:12px; opacity:.8; text-align:center; margin-top:6px; }
  /* Hall of Fame overlay (retro) */
  .hof {
    position:fixed; inset:0; display:none; align-items:center; justify-content:center;
    background:rgba(0,0,0,.6); z-index:10;
  }
  .hof-inner {
    width:min(880px, 92vw); background:#060d1c; border:1px solid rgba(255,255,255,.1);
    border-radius:14px; padding:22px 18px; box-shadow:0 12px 40px rgba(0,0,0,.6);
  }
  .hof-title { text-align:center; font-weight:900; font-size:26px; margin-bottom:4px; letter-spacing:.5px; }
  .hof-sub { text-align:center; font-size:12px; opacity:.8; margin-bottom:12px; }
  .cols { display:grid; grid-template-columns:1fr 1fr; gap:16px; }
  .board { background:#0b1220; border:1px solid rgba(255,255,255,.07); border-radius:10px; padding:10px 12px; }
  .board h4 { text-align:center; margin:0 0 8px 0; letter-spacing:.5px; }
  .board .line { display:flex; justify-content:space-between; font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, monospace; font-size:13px; padding:2px 0; }
  .topbar { display:flex; align-items:center; justify-content:center; gap:12px; margin-bottom:10px; }
  .badge { padding:2px 8px; border:1px solid rgba(255,255,255,.15); border-radius:999px; background:#081025; font-size:12px; }
</style>
</head>
<body>
<div class="shell">
  <!-- Retro sidebar HUD -->
  <aside class="sidebar mono" id="sidebar">
    <div class="sb-title">MataTudo</div>
    <div class="sb-card">
      <div class="row"><span>Score</span><span id="sbScore" class="hudnum">0</span></div>
      <div class="row"><span>Best</span><span id="sbBest" class="hudnum">0</span></div>
      <div class="row"><span>Level</span><span id="sbLevel" class="hudnum">1</span></div>
      <div class="row"><span>Mult</span><span id="sbMult" class="hudnum">x1</span></div>
      <div class="row"><span>Power</span><span id="sbPower" class="hudnum">-</span></div>
    </div>
    <div class="sb-card">
      <div class="row"><span>HP</span><span id="sbHPNum" class="hudnum">100</span></div>
      <div class="hpbar"><div id="sbHPFill" class="hpfill"></div></div>
    </div>
    <div class="sb-card mini">
      <div>Tips</div>
      <ul style="margin:6px 0 0 16px; padding:0;">
        <li>WASD / Arrows move</li>
        <li>Mouse aims, click shoots</li>
        <li>M mute · R restart</li>
        <li>Level +1 every 30 kills</li>
        <li>Boss every 4 levels</li>
      </ul>
    </div>
    <div class="sb-card mini">
      <div>Music</div>
      <div class="row"><button id="mute" class="btn">Mute</button><label>Vol <input id="vol" type="range" min="0" max="1" step="0.05" value="0.7"></label></div>
    </div>
    <div class="sb-card mini">
      <button id="pause" class="btn" style="width:100%;">Pause</button>
    </div>
  </aside>

  <!-- Playfield + controls -->
  <main>
    <div class="title">MataTudo — Alpha 13</div>
    <canvas id="game" width="1140" height="708"></canvas>
    <div class="hint">Any Key/Click starts • Level every 30 kills • Boss every 4 levels • Yellow bots give 2 pts • Map persists on Game Over</div>
  </main>
</div>

<!-- Hall of Fame (Game Over) -->
<div class="hof" id="hof">
  <div class="hof-inner">
    <div class="hof-title">HALL OF FAME</div>
    <div class="hof-sub mono" id="hofSummary">Score 0 · Level 1 · Accuracy 0%</div>
    <div class="topbar">
      <div class="badge" id="hofTodayBadge">TODAY'S GREATEST</div>
      <div class="badge" id="hofAllBadge">ALL‑TIME GREATEST</div>
    </div>
    <div class="cols">
      <div class="board">
        <h4>TODAY'S GREATEST</h4>
        <div id="boardToday"></div>
      </div>
      <div class="board">
        <h4>ALL‑TIME GREATEST</h4>
        <div id="boardAll"></div>
      </div>
    </div>
    <div class="hint" style="margin-top:12px;">Press <b>R</b> or click to restart</div>
  </div>
</div>

<script>
(() => {
  // ---------- Config ----------
  const W = 1140, H = 708, MAP_MARGIN = 12;
  const LEVEL_KILLS = 30;
  const MEDKIT_EVERY = 25;
  const MUSIC_MAIN_URL = "https://raw.githubusercontent.com/esteves7771/MataTudo/main/retro-synthwave-gaming-music-270173.mp3";
  const MUSIC_BOSS_URL = "https://raw.githubusercontent.com/esteves7771/MataTudo/main/cyberpunk-gaming-144149.mp3";

  const BOT_BULLET_DMG = 8.5, BOT_TOUCH_DMG = 8.5;

  // Boss buff + phase scaling
  const BOSS_HP = 1150; // was ~770
  const BOSS_R = 30;

  // ---------- DOM ----------
  const cvs = document.getElementById('game');
  const ctx = cvs.getContext('2d', { alpha:false });

  // sidebar refs
  const sbScore = document.getElementById('sbScore');
  const sbBest  = document.getElementById('sbBest');
  const sbLevel = document.getElementById('sbLevel');
  const sbMult  = document.getElementById('sbMult');
  const sbPower = document.getElementById('sbPower');
  const sbHPNum = document.getElementById('sbHPNum');
  const sbHPFill= document.getElementById('sbHPFill');

  const btnPause = document.getElementById('pause');
  const btnMute  = document.getElementById('mute');
  const vol      = document.getElementById('vol');

  // Hall of Fame
  const hof = document.getElementById('hof');
  const hofSummary = document.getElementById('hofSummary');
  const boardToday = document.getElementById('boardToday');
  const boardAll   = document.getElementById('boardAll');

  // ---------- Helpers ----------
  const clamp=(v,a,b)=>Math.max(a,Math.min(b,v));
  const rand=(a,b)=>a+Math.random()*(b-a);
  const rectOverAny=(r,arr)=>arr.some(o=>!(r.x+r.w<o.x||r.x>o.x+o.w||r.y+r.h<o.y||r.y>o.y+o.h));
  const rectCircleOverlap=(cx,cy,rr,o)=>{const nx=clamp(cx,o.x,o.x+o.w),ny=clamp(cy,o.y,o.y+o.h);const dx=cx-nx,dy=cy-ny;return dx*dx+dy*dy<=rr*rr};
  const bulletHitsObstacle=(b,o)=>(b.x+b.r>o.x&&b.x-b.r<o.x+o.w&&b.y+b.r>o.y&&b.y-b.r<o.y+o.h);

  function addShake(s, m=6, d=0.2){ s.shakeMag=Math.max(s.shakeMag||0,m); s.shakeT=Math.max(s.shakeT||0,d); }
  function applyShake(s){ if((s.shakeT||0)<=0) return; s.shakeT-=s.dt; const m=(s.shakeMag||0)*(s.shakeT>0? s.shakeT:0); ctx.translate((Math.random()*2-1)*m,(Math.random()*2-1)*m); }

  // ---------- Audio ----------
  const audio={ ctx:null, master:null, sfxGain:null, muted:false, main:null, boss:null, current:'main' };
  function ensureAC(){ if(audio.muted) return; if(!audio.ctx){ const AC=window.AudioContext||window.webkitAudioContext; if(!AC) return; const ac=new AC(); const master=ac.createGain(); master.gain.value=parseFloat(vol.value); master.connect(ac.destination); const sfx=ac.createGain(); sfx.gain.value=1; sfx.connect(master); audio.ctx=ac; audio.master=master; audio.sfxGain=sfx; } else if(audio.ctx.state==='suspended'){ audio.ctx.resume(); } }
  function setVolume(x){ if(audio.master) audio.master.gain.value=x; if(audio.main) audio.main.volume=audio.muted?0:x; if(audio.boss) audio.boss.volume=audio.muted?0:x; }
  function toggleMute(){ audio.muted=!audio.muted; btnMute.textContent=audio.muted?'Unmute':'Mute'; setVolume(audio.muted?0:parseFloat(vol.value)); if(audio.muted){ audio.main?.pause(); audio.boss?.pause(); } else if(s.mode==='playing'){ (audio.current==='boss'?audio.boss:audio.main)?.play().catch(()=>{}); } }
  function makeAudioEl(url){ const a=new Audio(url); a.loop=true; a.crossOrigin='anonymous'; a.preload='auto'; a.volume=parseFloat(vol.value); return a; }
  function startMainMusic(){ if(!audio.main) audio.main=makeAudioEl(MUSIC_MAIN_URL); if(!audio.muted) audio.main.play().catch(()=>{}); audio.current='main'; }
  function startBossMusic(){ if(!audio.boss) audio.boss=makeAudioEl(MUSIC_BOSS_URL); if(!audio.muted) audio.boss.play().catch(()=>{}); audio.current='boss'; }
  function stopAllMusic(){ audio.main?.pause(); audio.boss?.pause(); if(audio.main) audio.main.currentTime=0; if(audio.boss) audio.boss.currentTime=0; }
  function quickBeep(freq=800,dur=0.06,type='square',gain=0.03){ if(audio.muted) return; ensureAC(); if(!audio.ctx) return; const ac=audio.ctx,osc=ac.createOscillator(),g=ac.createGain(); osc.type=type; osc.frequency.value=freq; g.gain.value=gain; osc.connect(g).connect(audio.sfxGain); const now=ac.currentTime; g.gain.setValueAtTime(gain,now); g.gain.exponentialRampToValueAtTime(0.0001,now+dur); osc.start(now); osc.stop(now+dur); }
  function noiseBurst(dur=0.25,gain=0.05){ if(audio.muted) return; ensureAC(); if(!audio.ctx) return; const ac=audio.ctx; const buf=ac.createBuffer(1,ac.sampleRate*dur,ac.sampleRate); const data=buf.getChannelData(0); for(let i=0;i<data.length;i++) data[i]=(Math.random()*2-1)*0.6; const src=ac.createBufferSource(); src.buffer=buf; const g=ac.createGain(); g.gain.value=gain; const lp=ac.createBiquadFilter(); lp.type='lowpass'; lp.frequency.value=1200; src.connect(lp).connect(g).connect(audio.sfxGain); const now=ac.currentTime; g.gain.setValueAtTime(gain,now); g.gain.exponentialRampToValueAtTime(0.0001,now+dur); src.start(now); }
  const SFX={ shot:()=>quickBeep(1100,0.045,'square',0.03), hit:()=>quickBeep(280,0.06,'sine',0.02), heal:()=>quickBeep(900,0.12,'triangle',0.035), death:(i=0.4)=>{ noiseBurst(0.22+0.15*i,0.04+0.06*i); quickBeep(200,0.3+0.15*i,'sawtooth',0.02+0.04*i);} };

  vol.addEventListener('input',()=>setVolume(parseFloat(vol.value)));
  btnMute.addEventListener('click',toggleMute);
  document.addEventListener('keydown',e=>{ if(e.key.toLowerCase()==='m') toggleMute(); });

  // ---------- State ----------
  const s={
    time:0,lastTime:0, running:true, dt:0,
    mode:'intro', introTime:0, countdown:2,
    level:1, levelUpFlash:0, pendingBoss:false,
    score:0, bestScore:0, mult:1, multT:0,
    shotsFired:0, shotsHit:0,
    lastMedkitAtScore:0, lastEliteAtScore:0,
    player:{ x:W/2, y:H/2, r:12, speed:240, hp:100, fireCooldown:0, flashTimer:0, hitCooldown:0, knockbackX:0, knockbackY:0, kbT:0 },
    keys:{}, mouse:{ x:W/2, y:H/2, down:false },
    bullets:[], bots:[], particles:[], medkits:[], explosions:[], hazards:[],
    groundPattern:null, spawnTimer:0,
    firstWaveRemaining:4, firstWaveInterval:0.4, firstWaveTimer:0.4,
    obstacles:[
      { x:360,y:230,w:120,h:110 }, { x:780,y:460,w:160,h:80 }, { x:560,y:120,w:90,h:90 }, { x:170,y:510,w:170,h:44 },
    ],
    obstacleAlpha:1, obstaclePhase:'stable', obstacleFadeT:0,
    shakeT:0, shakeMag:0,
    banner:null, spawnEase:1.0, spawnEaseT:0,
    power:{kind:null,t:0},
    todayScores: []
  };
  try{ const saved=localStorage.getItem('matatudo_best'); if(saved) s.bestScore=parseInt(saved,10)||0; }catch{}

  // pattern
  (function(){
    const pc=document.createElement('canvas'); pc.width=64; pc.height=64;
    const pg=pc.getContext('2d');
    pg.fillStyle='#27303a'; pg.fillRect(0,0,64,64);
    for(let i=0;i<140;i++){ pg.fillStyle=`rgba(255,255,255,${0.06+Math.random()*0.06})`; pg.fillRect(Math.random()*64,Math.random()*64,1,1); }
    pg.strokeStyle='rgba(0,0,0,0.12)';
    for(let x=0;x<=64;x+=16){ pg.beginPath(); pg.moveTo(x,0); pg.lineTo(x,64); pg.stroke(); }
    for(let y=0;y<=64;y+=16){ pg.beginPath(); pg.moveTo(0,y); pg.lineTo(64,y); pg.stroke(); }
    s.groundPattern=ctx.createPattern(pc,'repeat');
  })();

  // ---------- Map gen (same logic as previous alpha; omitted here for brevity of comments) ----------
  const MIN_GAP=28, MAX_OBS_W=240, MAX_OBS_H=200;
  function insetToPlayArea(x,y,w,h){ const left=MAP_MARGIN+MIN_GAP, top=MAP_MARGIN+MIN_GAP, right=W-MAP_MARGIN-MIN_GAP, bottom=H-MAP_MARGIN-MIN_GAP; w=Math.min(w,right-left); h=Math.min(h,bottom-top); x=clamp(x,left,right-w); y=clamp(y,top,bottom-h); return {x,y,w,h}; }
  const rectCircle=(cx,cy,r,o)=>rectCircleOverlap(cx,cy,r,o);
  const entityBlockedBy=(x,y,r,obs)=>obs.some(o=>rectCircle(x,y,r,o));
  function generateCandidateObstacles(currentEntities){
    const obstacles=[]; const add=(x,y,w,h)=>{ w=Math.min(w,MAX_OBS_W); h=Math.min(h,MAX_OBS_H); const r=insetToPlayArea(x,y,w,h); const infl={x:r.x-MIN_GAP/2,y:r.y-MIN_GAP/2,w:r.w+MIN_GAP,h:r.h+MIN_GAP}; if(rectOverAny(infl,obstacles.map(o=>({x:o.x-MIN_GAP/2,y:o.y-MIN_GAP/2,w:o.w+MIN_GAP,h:o.h+MIN_GAP})))) return; const wouldCover=currentEntities.some(ent=>rectCircle(ent.x,ent.y,ent.r+2,r)); if(wouldCover) return; obstacles.push(r); };
    const pat=2+Math.floor(Math.random()*2);
    for(let k=0;k<pat;k++){ const p=Math.floor(Math.random()*3);
      if(p===0){ const cx=MAP_MARGIN+160+Math.random()*(W-2*(MAP_MARGIN+160)); const cy=MAP_MARGIN+120+Math.random()*(H-2*(MAP_MARGIN+120)); const cw=80+Math.random()*130, ch=60+Math.random()*110; add(cx-cw/2,cy-ch/2,cw,ch); const n=3+Math.floor(Math.random()*4); for(let i=0;i<n;i++){ const w=40+Math.random()*90,h=30+Math.random()*80; add(cx+(Math.random()*280-140)-w/2, cy+(Math.random()*200-100)-h/2, w,h);} }
      else if(p===1){ const bars=3+Math.floor(Math.random()*3); for(let i=0;i<bars;i++){ const horiz=Math.random()<0.5; if(horiz){ const w=180+Math.random()*240,h=22+Math.random()*36; add(MAP_MARGIN+Math.random()*(W-2*MAP_MARGIN-w), MAP_MARGIN+Math.random()*(H-2*MAP_MARGIN-h), w,h); } else { const w=22+Math.random()*36,h=180+Math.random()*240; add(MAP_MARGIN+Math.random()*(W-2*MAP_MARGIN-w), MAP_MARGIN+Math.random()*(H-2*MAP_MARGIN-h), w,h); } } }
      else { const count=7+Math.floor(Math.random()*8); for(let i=0;i<count;i++){ const w=50+Math.random()*120,h=50+Math.random()*120; add(MAP_MARGIN+Math.random()*(W-2*MAP_MARGIN-w), MAP_MARGIN+Math.random()*(H-2*MAP_MARGIN-h), w,h); } }
    }
    if(obstacles.length>18) obstacles.length=18;
    return obstacles;
  }
  function randomObstaclesNavigable(){
    const ents=[{x:s.player.x,y:s.player.y,r:80}].concat(s.bots.map(b=>({x:b.x,y:b.y,r:b.r+20})));
    for(let tries=0;tries<30;tries++){ const obs=generateCandidateObstacles(ents); if(doorsReachable(obs,s.player.x,s.player.y)) return obs; }
    return s.obstacles;
  }
  const GRID_CELLS_X=45, GRID_CELLS_Y=27;
  function doorsReachable(obstacles, px, py){
    const grid=Array.from({length:GRID_CELLS_Y},()=>Array(GRID_CELLS_X).fill(0));
    const cellW=(W-2*MAP_MARGIN)/GRID_CELLS_X, cellH=(H-2*MAP_MARGIN)/GRID_CELLS_Y;
    for(let y=0;y<GRID_CELLS_Y;y++){ for(let x=0;x<GRID_CELLS_X;x++){ const cx=MAP_MARGIN+x*cellW+cellW/2, cy=MAP_MARGIN+y*cellH+cellH/2; if(obstacles.some(o=>rectCircle(cx,cy,12+MIN_GAP/2,o))) grid[y][x]=1; } }
    const gx=clamp(Math.floor((px-MAP_MARGIN)/cellW),0,GRID_CELLS_X-1), gy=clamp(Math.floor((py-MAP_MARGIN)/cellH),0,GRID_CELLS_Y-1);
    if(grid[gy][gx]===1) return false;
    const seen=Array.from({length:GRID_CELLS_Y},()=>Array(GRID_CELLS_X).fill(false)); const q=[[gx,gy]], dirs=[[1,0],[-1,0],[0,1],[0,-1]]; seen[gy][gx]=true;
    while(q.length){ const [x,y]=q.shift(); for(const [dx,dy] of dirs){ const nx=x+dx, ny=y+dy; if(nx<0||ny<0||nx>=GRID_CELLS_X||ny>=GRID_CELLS_Y) continue; if(seen[ny][nx]||grid[ny][nx]===1) continue; seen[ny][nx]=true; q.push([nx,ny]); } }
    const doors=[{gx:Math.floor(GRID_CELLS_X/2),gy:0},{gx:Math.floor(GRID_CELLS_X/2),gy:GRID_CELLS_Y-1},{gx:0,gy:Math.floor(GRID_CELLS_Y/2)},{gx:GRID_CELLS_X-1,gy:Math.floor(GRID_CELLS_Y/2)}];
    return doors.every(d=>seen[d.gy][d.gx]===true);
  }
  function triggerObstacleSwap(){ s.obstaclePhase='fadeOut'; s.obstacleFadeT=0; }
  function updateObstacleFade(dt){
    if(s.obstaclePhase==='stable') return;
    const DUR=0.45; s.obstacleFadeT+=dt; const t=clamp(s.obstacleFadeT/DUR,0,1);
    if(s.obstaclePhase==='fadeOut'){ s.obstacleAlpha=1-t; if(s.obstacleFadeT>=DUR){ s.obstacles=randomObstaclesNavigable(); s.obstaclePhase='fadeIn'; s.obstacleFadeT=0; } }
    else { s.obstacleAlpha=t; if(s.obstacleFadeT>=DUR){ s.obstaclePhase='stable'; s.obstacleAlpha=1; } }
  }

  // ---------- Hazards ----------
  function spawnHazards(n=2){ for(let i=0;i<n;i++){ const r=10,x=rand(MAP_MARGIN+50,W-MAP_MARGIN-50),y=rand(MAP_MARGIN+50,H-MAP_MARGIN-50); s.hazards.push({x,y,r,vx:rand(-120,120),vy:rand(-120,120)}); } }

  // ---------- Spawners / FX ----------
  function spawnParticles(x,y,color,count,size=2){ for(let i=0;i<count;i++){ const a=Math.random()*Math.PI*2,v=40+Math.random()*80; s.particles.push({x,y,vx:Math.cos(a)*v,vy:Math.sin(a)*v,life:0.4+Math.random()*0.4,color,size}); } }
  function spawnExplosion(x,y,scale=1,color='#ffcf6b'){ s.explosions.push({x,y,t:0,dur:0.35,r0:8*scale,r1:36*scale,color}); }

  // Boss patterns + scaling
  function bossShootAimed(b){ const p=s.player; const a=Math.atan2(p.y-b.y,p.x-b.x)+(Math.random()-0.5)*0.1; const sp=480; s.bullets.push({x:b.x,y:b.y,vx:Math.cos(a)*sp,vy:Math.sin(a)*sp,r:3,owner:'bot',life:2,boss:true}); }
  function bossShootBurst(b){ const N=12, base=Math.random()*Math.PI*2; for(let i=0;i<N;i++){ const a=base+i*(Math.PI*2/N); const sp=400; s.bullets.push({x:b.x,y:b.y,vx:Math.cos(a)*sp,vy:Math.sin(a)*sp,r:3,owner:'bot',life:2,boss:true}); } }
  function bossShootSpiral(b){ b.spiralA=(b.spiralA||0)+0.38; const sp=420, a=b.spiralA; s.bullets.push({x:b.x,y:b.y,vx:Math.cos(a)*sp,vy:Math.sin(a)*sp,r:3,owner:'bot',life:2,boss:true}); }

  function vectorToPlayer(b){ const dx=s.player.x-b.x, dy=s.player.y-b.y; const d=Math.hypot(dx,dy)||1; return {dx,dy,d,ax:dx/d,ay:dy/d}; }

  function spawnBot(elite=false,boss=false){
    let tries=0,x=0,y=0,r=boss?BOSS_R:(elite?16:12);
    while(tries++<60){ const edge=Math.floor(Math.random()*4); if(edge===0){x=MAP_MARGIN+r+2;y=rand(MAP_MARGIN,H-MAP_MARGIN);} else if(edge===1){x=W-MAP_MARGIN-r-2;y=rand(MAP_MARGIN,H-MAP_MARGIN);} else if(edge===2){x=rand(MAP_MARGIN,W-MAP_MARGIN);y=MAP_MARGIN+r+2;} else {x=rand(MAP_MARGIN,W-MAP_MARGIN);y=H-MAP_MARGIN-r-2;} if(!entityBlockedBy(x,y,r,s.obstacles)) break; }
    const base= boss? 70 : 80+Math.random()*35;
    const hp  = boss? BOSS_HP : (elite?200:40);
    const speed = base * (1 + 0.08*(s.level-1)) * (elite?0.9:1);
    const shootEvery = (boss? 0.6 : (0.9+Math.random()*0.9)) * (elite?0.85:1);

    let ai='rusher';
    if(!boss){ const r=Math.random(); ai = r<0.25?'strafer':r<0.5?'circler':r<0.75?'sniper':'rusher'; }
    let speedMul=1, extraHP=0, mod=null;
    if(!boss){ if(Math.random()<0.15){speedMul=1.35; mod=(mod||'')+'S';} if(Math.random()<0.12){extraHP=40; mod=(mod||'')+'H';} }

    const bot={ x,y,r,speed:speed*speedMul,hp:hp+extraHP,fireCooldown:0,shootEvery,jitter:Math.random()*Math.PI*2,elite,boss,mod,outline:(boss?'#f88':(mod?'#7cf':null)), ai, phase:'aim',phaseT:0,spiralA:0, maxHP:hp+extraHP };
    s.bots.push(bot);
  }
  function spawnBossSolo(){ s.bots = s.bots.filter(b=>b.boss); startBossMusic(); audio.main?.pause(); s.banner={text:'BOSS INCOMING!',t:0,dur:1.8}; spawnBot(false,true); }

  function trySpawnMedkit(){
    if(s.score>0 && s.score%MEDKIT_EVERY===0 && s.lastMedkitAtScore!==s.score){
      for(let i=0;i<80;i++){ const r=10,x=MAP_MARGIN+r+Math.random()*(W-2*(MAP_MARGIN+r)), y=MAP_MARGIN+r+Math.random()*(H-2*(MAP_MARGIN+r)); if(entityBlockedBy(x,y,r,s.obstacles)) continue; s.medkits.push({x,y,r,timeLeft:20,heal:30}); s.lastMedkitAtScore=s.score; break; }
    }
  }
  function maybeDropPowerup(x,y){ if(Math.random()<0.08){ const pick=Math.random(); const kind=pick<0.34?'rapid':pick<0.68?'shotgun':'explosive'; s.medkits.push({x,y,r:11,timeLeft:18,power:kind}); } }

  function maybeLevelUp(){
    const next=Math.floor(s.score/LEVEL_KILLS)+1;
    if(next>s.level){ s.level=next; s.levelUpFlash=2; triggerObstacleSwap(); if(s.level%4===0) s.pendingBoss=true; if(s.level%3===0 && s.hazards.length<5) spawnHazards(1); }
  }

  function startGame(){
    ensureAC(); stopAllMusic(); startMainMusic();
    s.player={ x:W/2, y:H/2, r:12, speed:240, hp:100, fireCooldown:0, flashTimer:0, hitCooldown:0, knockbackX:0, knockbackY:0, kbT:0 };
    s.bullets=[]; s.bots=[]; s.particles=[]; s.explosions=[]; // map persists
    s.spawnTimer=0; s.score=0; s.mult=1; s.multT=0; s.lastEliteAtScore=0; s.lastMedkitAtScore=0;
    s.firstWaveRemaining=4; s.firstWaveTimer=s.firstWaveInterval;
    s.level=1; s.levelUpFlash=0; s.obstaclePhase='stable'; s.obstacleAlpha=1; s.pendingBoss=false;
    s.shotsFired=0; s.shotsHit=0; s.power={kind:null,t:0}; s.spawnEase=1; s.spawnEaseT=0;
    s.mode='countdown'; s.countdown=2;
    hof.style.display='none';
  }

  // ---------- Update ----------
  function updateSidebar(){
    sbScore.textContent = s.score;
    sbBest.textContent  = s.bestScore;
    sbLevel.textContent = s.level;
    sbMult.textContent  = 'x'+s.mult;
    sbPower.textContent = s.power.kind? `${s.power.kind} ${Math.ceil(s.power.t)}s` : '-';
    const hp = Math.max(0, Math.round(s.player.hp));
    sbHPNum.textContent = hp;
    sbHPFill.style.width = (hp)+'%';
    sbHPFill.style.background = hp<25 ? 'linear-gradient(90deg,#ff6b6b,#b91c1c)' : 'linear-gradient(90deg,#2af598,#08a88a)';
  }

  function update(dt){
    s.dt=dt; s.time+=dt; updateObstacleFade(dt); updateSidebar();
    if(s.banner){ s.banner.t+=dt; if(s.banner.t>=s.banner.dur) s.banner=null; }
    if(s.power.kind){ s.power.t-=dt; if(s.power.t<=0) s.power.kind=null; }
    if(!s.running) return;

    if(s.mode==='intro'){ s.introTime+=dt; if(s.introTime>1.6){ s.mode='menu'; stopAllMusic(); } return; }
    if(s.mode==='menu') return;
    if(s.mode==='countdown'){ s.countdown-=dt; if(s.countdown<=0) s.mode='playing'; return; }
    if(s.mode!=='playing') return;

    // hazards
    s.hazards.forEach(h=>{ h.x+=h.vx*dt; h.y+=h.vy*dt; if(h.x<MAP_MARGIN+h.r||h.x>W-MAP_MARGIN-h.r) h.vx*=-1; if(h.y<MAP_MARGIN+h.r||h.y>H-MAP_MARGIN-h.r) h.vy*=-1; });

    // spawns
    const bossAlive = s.bots.some(b=>b.boss);
    s.spawnTimer-=dt;
    if(!bossAlive && !s.pendingBoss){
      const spawnBase = Math.max(0.5, 1.6 - Math.min(60, s.score/5)*0.01);
      const spawnScaled = Math.max(0.25, spawnBase * (1 - 0.06*(s.level-1)));
      if(s.spawnTimer<=0){ const eliteChance=Math.min(0.5,0.05*s.level); spawnBot(Math.random()<eliteChance,false); s.spawnTimer=spawnScaled; }
      if(s.firstWaveRemaining>0){ s.firstWaveTimer-=dt; if(s.firstWaveTimer<=0){ spawnBot(false,false); s.firstWaveRemaining--; s.firstWaveTimer=s.firstWaveInterval; } }
      if(s.score>0 && s.score%20===0 && s.lastEliteAtScore!==s.score){ spawnBot(true,false); s.lastEliteAtScore=s.score; }
    }
    if(s.pendingBoss && !bossAlive){ startBossMusic(); audio.main?.pause(); s.banner={text:'BOSS INCOMING!',t:0,dur:1.8}; spawnBot(false,true); s.pendingBoss=false; }

    // player
    const p=s.player; p.hitCooldown=Math.max(0,p.hitCooldown-dt); p.flashTimer=Math.max(0,p.flashTimer-dt); p.kbT=Math.max(0,p.kbT-dt);
    let ix=0,iy=0; if(s.keys['w']||s.keys['arrowup'])iy--; if(s.keys['s']||s.keys['arrowdown'])iy++; if(s.keys['a']||s.keys['arrowleft'])ix--; if(s.keys['d']||s.keys['arrowright'])ix++;
    const mag=Math.hypot(ix,iy)||1; let mvx=ix/mag*p.speed*dt, mvy=iy/mag*p.speed*dt;
    if(p.kbT>0){ mvx += p.knockbackX*(p.kbT*4)*dt; mvy += p.knockbackY*(p.kbT*4)*dt; }
    let nx=clamp(p.x+mvx,MAP_MARGIN+p.r,W-MAP_MARGIN-p.r); if(!s.obstacles.some(o=>rectCircle(nx,p.y,p.r,o))) p.x=nx;
    let ny=clamp(p.y+mvy,MAP_MARGIN+p.r,H-MAP_MARGIN-p.r); if(!s.obstacles.some(o=>rectCircle(p.x,ny,p.r,o))) p.y=ny;

    // fire
    p.fireCooldown-=dt;
    if(s.mouse.down && p.fireCooldown<=0){
      const dx=s.mouse.x-p.x, dy=s.mouse.y-p.y, d=Math.hypot(dx,dy)||1, baseAng=Math.atan2(dy,dx);
      let shots=1, spread=0, cooldown=0.15, speed=520;
      if(s.level>=5){ shots=3; spread=0.12; } else if(s.level>=2){ shots=2; spread=0.07; }
      if(s.power.kind==='rapid') cooldown*=0.5;
      if(s.power.kind==='shotgun'){ shots=Math.max(shots,5); spread=Math.max(spread,0.2); speed=500; }
      const pushBullet=(ang,exp)=>s.bullets.push({x:p.x,y:p.y,vx:Math.cos(ang)*speed,vy:Math.sin(ang)*speed,r:3,owner:'player',life:2,explosive:exp});
      if(shots===1) pushBullet(baseAng,s.power.kind==='explosive'); else { const half=(shots-1)/2; for(let i=0;i<shots;i++){ const ang=baseAng+(i-half)*spread; pushBullet(ang,s.power.kind==='explosive'); } }
      s.shotsFired+=shots; spawnParticles(p.x+Math.cos(baseAng)*p.r,p.y+Math.sin(baseAng)*p.r,'#fff8',6,1.6);
      p.flashTimer=0.07; p.fireCooldown=cooldown; SFX.shot();
    }

    // bot AI + fire
    s.bots.forEach(b=>{
      b.jitter=(b.jitter||0)+dt*2.2;
      const v={ dx:s.player.x-b.x, dy:s.player.y-b.y }; const d=Math.hypot(v.dx,v.dy)||1; let ax=v.dx/d, ay=v.dy/d;
      if(!b.boss){
        if(b.ai==='strafer'){ const side=Math.sin(s.time*2+b.jitter)>0?1:-1; const a=Math.atan2(v.dy,v.dx)+side*Math.PI/2; ax=Math.cos(a); ay=Math.sin(a); }
        else if(b.ai==='circler'){ const a=Math.atan2(v.dy,v.dx)+Math.sin(b.jitter)*0.5; ax=Math.cos(a); ay=Math.sin(a); }
        else if(b.ai==='sniper'){ if(d<260){ ax=-ax; ay=-ay; } else { ax*=0.3; ay*=0.3; } }
      }
      const totalDx=ax*b.speed*dt,totalDy=ay*b.speed*dt, steps=Math.max(1,Math.ceil(Math.hypot(totalDx,totalDy)/Math.max(1,b.r*0.6)));
      const stepX=totalDx/steps, stepY=totalDy/steps;
      for(let i=0;i<steps;i++){ let tx=b.x+stepX, ty=b.y; if(!s.obstacles.some(o=>rectCircle(tx,b.y,b.r,o))) b.x=clamp(tx,MAP_MARGIN+b.r,W-MAP_MARGIN-b.r); ty=b.y+stepY; if(!s.obstacles.some(o=>rectCircle(b.x,ty,b.r,o))) b.y=clamp(ty,MAP_MARGIN+b.r,H-MAP_MARGIN-b.r); }

      b.fireCooldown-=dt;
      if(b.boss){
        // tougher phases if low HP
        const hpFrac = Math.max(0,b.hp)/(b.maxHP||BOSS_HP);
        const rateMul = hpFrac < 0.5 ? 0.75 : 1; // faster fire when low
        b.phaseT += dt;
        if(b.phase==='aim'){ if(b.fireCooldown<=0){ bossShootAimed(b); b.fireCooldown=0.35*rateMul; } if(b.phaseT>3) { b.phase='burst'; b.phaseT=0; } }
        else if(b.phase==='burst'){ if(b.fireCooldown<=0){ bossShootBurst(b); b.fireCooldown=1.0*rateMul; } if(b.phaseT>3.2){ b.phase='spiral'; b.phaseT=0; } }
        else { if(b.fireCooldown<=0){ bossShootSpiral(b); b.fireCooldown=0.06*rateMul; } if(b.phaseT>3){ b.phase='aim'; b.phaseT=0; } }
      } else if(b.fireCooldown<=0){
        const aa=Math.atan2(v.dy,v.dx)+(Math.random()-0.5)*0.18; const sp=360;
        s.bullets.push({x:b.x,y:b.y,vx:Math.cos(aa)*sp,vy:Math.sin(aa)*sp,r:3,owner:'bot',life:2}); b.fireCooldown=b.shootEvery*Math.max(0.55,1-0.05*(s.level-1));
      }
    });

    // bullets
    s.bullets.forEach(b=>{ b.x+=b.vx*dt; b.y+=b.vy*dt; b.life-=dt; });
    s.bullets = s.bullets.filter(b=>b.life>0 && b.x>-10 && b.x<W+10 && b.y>-10 && b.y<H+10 && !s.obstacles.some(o=>bulletHitsObstacle(b,o)));

    // hazards damage
    s.hazards.forEach(h=>{ if(Math.hypot(h.x-s.player.x,h.y-s.player.y)<h.r+s.player.r){ if(s.player.hitCooldown<=0){ s.player.hp-=10; s.player.hitCooldown=0.35; SFX.hit(); addShake(s,6,0.25); } } });

    // hits
    s.bullets.forEach(b=>{ if(b.owner==='bot' && Math.hypot(b.x-p.x,b.y-p.y)<b.r+p.r){ if(p.hitCooldown<=0){ p.hp-=BOT_BULLET_DMG; p.hitCooldown=0.35; spawnParticles(p.x,p.y,'#f00',8,2.2); SFX.hit(); addShake(s,6,0.25); p.knockbackX=(p.x-b.x)/Math.hypot(p.x-b.x,p.y-b.y); p.knockbackY=(p.y-b.y)/Math.hypot(p.x-b.x,p.y-b.y); p.kbT=0.2; s.mult=1; s.multT=0; } b.life=0; } });

    s.bots = s.bots.filter(b=>{
      let alive=true;
      s.bullets.forEach(pr=>{
        if(pr.owner==='player' && Math.hypot(b.x-pr.x,b.y-pr.y)<b.r+pr.r){
          b.hp-=25; pr.life=0; spawnParticles(b.x,b.y,'#f33',10,2); SFX.hit(); s.shotsHit++;
          if(pr.explosive){ spawnExplosion(pr.x,pr.y,1.1,'#ffa07a'); s.bots.forEach(bb=>{ const d=Math.hypot(bb.x-pr.x,bb.y-pr.y); if(d<70) bb.hp -= 22*(1-d/70); }); }
          if(b.hp<=0){
            alive=false; const over=-b.hp; const extra=20+Math.min(40,Math.max(0,Math.round(over*1.2)));
            spawnParticles(b.x,b.y,b.boss?'#ff8888':(b.elite?'#ffd372':'#ff7b72'),extra,3); spawnExplosion(b.x,b.y,b.boss?1.8:(b.elite?1.2:1), b.boss?'#ff6666':'#ffb16b');
            if(over>30||b.boss) addShake(s,b.boss?12:8,0.35);
            const base=b.boss?5:(b.elite?2:1); s.multT=Math.min(5,s.multT+1.25); s.mult=Math.min(5,1+Math.floor(s.multT)); s.score+=base*s.mult;
            if(b.boss){ s.medkits.push({x:b.x,y:b.y,r:12,timeLeft:30,heal:60}); audio.boss?.pause(); startMainMusic(); }
            else { maybeDropPowerup(b.x,b.y); }
            SFX.death(Math.min(1,over/50)); maybeLevelUp();
          }
        }
      });
      return alive;
    });

    // touch dmg
    s.bots.forEach(b=>{ if(Math.hypot(b.x-p.x,b.y-p.y)<b.r+p.r){ if(p.hitCooldown<=0){ p.hp-=BOT_TOUCH_DMG; p.hitCooldown=0.35; spawnParticles(p.x,p.y,'#f00',8,2.2); SFX.hit(); addShake(s,6,0.25); p.knockbackX=(p.x-b.x)/Math.hypot(p.x-b.x,p.y-b.y); p.knockbackY=(p.y-b.y)/Math.hypot(p.x-b.x,p.y-b.y); p.kbT=0.25; s.mult=1; s.multT=0; } } });

    // pickups
    trySpawnMedkit();
    s.medkits.forEach(m=>m.timeLeft-=dt);
    s.medkits = s.medkits.filter(m=>{
      if(m.timeLeft<=0) return false;
      if(Math.hypot(m.x-p.x,m.y-p.y)<m.r+p.r){
        if(m.power){ s.power={kind:m.power,t:15}; spawnParticles(m.x,m.y,'#c8f7ff',18,2.6); }
        else { p.hp=Math.min(100,p.hp+(m.heal||30)); spawnParticles(m.x,m.y,'#8cff8c',18,2.6); SFX.heal(); }
        return false;
      }
      return true;
    });

    // particles & explosions
    s.explosions.forEach(ex=>ex.t+=dt); s.explosions=s.explosions.filter(ex=>ex.t<ex.dur);
    s.particles.forEach(pt=>{ pt.x+=pt.vx*dt; pt.y+=pt.vy*dt; pt.life-=dt; }); s.particles=s.particles.filter(pt=>pt.life>0);

    // death
    if(p.hp<=0){
      s.mode='gameover'; stopAllMusic();
      try{ if(s.score>(s.bestScore||0)){ s.bestScore=s.score; localStorage.setItem('matatudo_best',String(s.bestScore)); } }catch{}
      updateHallOfFame();
      hof.style.display='flex'; // keep map visible under overlay
    }
    s.levelUpFlash=Math.max(0,s.levelUpFlash-dt);
  }

  // ---------- Drawing ----------
  function drawSoldier(x,y,ang,r,flash,lowHP){
    ctx.save(); ctx.translate(x,y); ctx.rotate(ang);
    ctx.fillStyle='rgba(0,0,0,0.25)'; ctx.beginPath(); ctx.ellipse(0,r*0.9,r*0.9,r*0.4,0,0,Math.PI*2); ctx.fill();
    const g=ctx.createRadialGradient(0,-r*0.2,r*0.2,0,0,r*1.05); g.addColorStop(0,lowHP?'#ff7b7b':'#34d27a'); g.addColorStop(1,lowHP?'#b33':'#228d4e'); ctx.fillStyle=g; ctx.beginPath(); ctx.arc(0,0,r,0,Math.PI*2); ctx.fill();
    ctx.fillStyle='#1e824c'; ctx.beginPath(); ctx.arc(0,-r*0.3,r*0.95,Math.PI,0); ctx.fill(); ctx.fillStyle='#145a32'; ctx.fillRect(-r,-r*0.3,r*2,r*0.15);
    ctx.fillStyle='#2ecc71'; ctx.fillRect(-r*1.2,-r*0.4,r*0.4,r*1.2); ctx.fillRect(r*0.8,-r*0.4,r*0.4,r*1.2);
    ctx.fillStyle='#dcdcdc'; ctx.fillRect(0,-3,r+14,6); ctx.fillStyle='#555'; ctx.fillRect(r+14,-2,4,4);
    if(flash>0){ ctx.fillStyle='rgba(255,240,120,0.9)'; ctx.beginPath(); ctx.ellipse(r+20,0,7,3.5,0,0,Math.PI*2); ctx.fill(); }
    ctx.restore();
  }
  function drawObstacle(o, alpha=1){ ctx.save(); ctx.globalAlpha=alpha; ctx.fillStyle='#4b5563'; ctx.fillRect(o.x,o.y,o.w,o.h); ctx.strokeStyle='rgba(0,0,0,0.25)'; ctx.strokeRect(o.x+0.5,o.y+0.5,o.w-1,o.h-1); ctx.fillStyle='rgba(255,255,255,0.08)'; for(let i=0;i<30;i++){ const rx=o.x+4+Math.random()*(o.w-8),ry=o.y+4+Math.random()*(o.h-8); ctx.fillRect(rx,ry,1,1);} ctx.restore(); }
  function drawBossTexture(b){
    const r=b.r; const grad=ctx.createRadialGradient(b.x-r*0.2,b.y-r*0.2,r*0.2,b.x,b.y,r*1.2); grad.addColorStop(0,'#ff6b6b'); grad.addColorStop(1,'#b81616');
    ctx.fillStyle=grad; ctx.beginPath(); ctx.arc(b.x,b.y,r,0,Math.PI*2); ctx.fill(); ctx.save(); ctx.clip(); ctx.globalAlpha=0.18; ctx.strokeStyle='#ffffff'; ctx.lineWidth=2;
    for(let a=-r;a<=r;a+=6){ ctx.beginPath(); ctx.moveTo(b.x-r,b.y+a); ctx.lineTo(b.x+r,b.y+a+8); ctx.stroke(); } ctx.restore();
  }
  function drawExplosions(){ s.explosions.forEach(ex=>{ const t=ex.t/ex.dur; const r=ex.r0+(ex.r1-ex.r0)*t, a=1-t; ctx.save(); ctx.globalAlpha=a*0.9; ctx.strokeStyle=ex.color; ctx.lineWidth=3; ctx.beginPath(); ctx.arc(ex.x,ex.y,r,0,Math.PI*2); ctx.stroke(); ctx.globalAlpha=a*0.35; ctx.fillStyle=ex.color; ctx.beginPath(); ctx.arc(ex.x,ex.y,r*0.6,0,Math.PI*2); ctx.fill(); ctx.restore(); }); }
  function draw(){
    ctx.save(); applyShake(s);
    ctx.fillStyle=s.groundPattern||'#0b1220'; ctx.fillRect(0,0,W,H);
    const low = s.player.hp<=25 && s.mode==='playing'; if(low){ const pulse=(Math.sin(s.time*10)+1)/2; ctx.strokeStyle=`rgba(255,70,70,${0.2+0.6*pulse})`; ctx.lineWidth=4; ctx.strokeRect(MAP_MARGIN-2,MAP_MARGIN-2,W-2*MAP_MARGIN+4,H-2*MAP_MARGIN+4); }
    ctx.strokeStyle='rgba(255,255,255,0.2)'; ctx.lineWidth=1; ctx.strokeRect(MAP_MARGIN,MAP_MARGIN,W-2*MAP_MARGIN,H-2*MAP_MARGIN);

    s.obstacles.forEach(o=>drawObstacle(o, s.obstacleAlpha));
    s.hazards.forEach(h=>{ ctx.fillStyle='#fbbf24'; ctx.beginPath(); ctx.arc(h.x,h.y,h.r,0,Math.PI*2); ctx.fill(); ctx.strokeStyle='#b45309'; ctx.lineWidth=2; ctx.beginPath(); ctx.arc(h.x,h.y,h.r+3,0,Math.PI*2); ctx.stroke(); });

    // pickups
    s.medkits.forEach(m=>{ const blink=m.timeLeft<5?(Math.floor(m.timeLeft*10)%2===0):true; if(!blink) return; const r=m.r;
      if(m.power){ ctx.fillStyle='#c8f7ff'; ctx.beginPath(); ctx.arc(m.x,m.y,r,0,Math.PI*2); ctx.fill(); ctx.fillStyle='#0ea5e9'; ctx.font='10px ui-sans-serif'; ctx.textAlign='center'; ctx.fillText(m.power[0].toUpperCase(), m.x, m.y+3); ctx.textAlign='start'; }
      else { ctx.fillStyle='#e5f7ff'; ctx.fillRect(m.x-r,m.y-r,r*2,r*2); ctx.strokeStyle='#94a3b8'; ctx.strokeRect(m.x-r+0.5,m.y-r+0.5,r*2-1,r*2-1); ctx.fillStyle='#e11d48'; ctx.fillRect(m.x-r*0.25,m.y-r*0.8,r*0.5,r*1.6); ctx.fillRect(m.x-r*0.8,m.y-r*0.25,r*1.6,r*0.5); }
    });

    const p=s.player; const ang=Math.atan2(s.mouse.y-p.y,s.mouse.x-p.x); drawSoldier(p.x,p.y,ang,p.r,p.flashTimer,low);
    s.bots.forEach(b=>{ ctx.save(); if(b.outline){ ctx.strokeStyle=b.outline; ctx.lineWidth=3; ctx.beginPath(); ctx.arc(b.x,b.y,b.r+3,0,Math.PI*2); ctx.stroke(); } if(b.boss) drawBossTexture(b); else { ctx.fillStyle=b.elite?'#f0c420':'#ff7b72'; ctx.beginPath(); ctx.arc(b.x,b.y,b.r,0,Math.PI*2); ctx.fill(); } ctx.strokeStyle='rgba(255,255,255,0.6)'; ctx.lineWidth=2; ctx.beginPath(); const frac=Math.max(0,b.hp)/(b.maxHP||40); ctx.arc(b.x,b.y,b.r+4,-Math.PI/2,-Math.PI/2+frac*Math.PI*2); ctx.stroke(); ctx.restore(); });
    s.bullets.forEach(b=>{ ctx.fillStyle=b.owner==='player'?'#e6ff71':(b.boss?'#ffb1b1':'#ffa8a3'); ctx.beginPath(); ctx.arc(b.x,b.y,b.r,0,Math.PI*2); ctx.fill(); });
    s.particles.forEach(pt=>{ ctx.fillStyle=pt.color; ctx.beginPath(); ctx.arc(pt.x,pt.y,pt.size,0,Math.PI*2); ctx.fill(); });
    drawExplosions();

    // overlays
    ctx.textAlign='center';
    if(s.levelUpFlash>0 && Math.floor(s.time*6)%2===0){ ctx.font='bold 28px ui-sans-serif,system-ui'; ctx.fillStyle='#fff'; ctx.fillText('Level Up!', W/2, MAP_MARGIN+34); }
    if(s.banner){ const alpha = 1 - Math.max(0,(s.banner.t/s.banner.dur)-0.6); ctx.globalAlpha=Math.max(0,alpha); ctx.fillStyle='rgba(0,0,0,0.55)'; ctx.fillRect(0,0,W,H); ctx.fillStyle='#fff'; ctx.font='bold 40px ui-sans-serif,system-ui'; ctx.fillText(s.banner.text, W/2, H/2); ctx.globalAlpha=1; }
    if(s.mode==='intro'){ ctx.fillStyle='rgba(0,0,0,0.7)'; ctx.fillRect(0,0,W,H); ctx.fillStyle='#fff'; const t=s.time; const a=Math.min(1,t/0.5)*(t<1.2?1:Math.max(0,2-t)); ctx.globalAlpha=a; ctx.font='bold 48px ui-sans-serif,system-ui'; ctx.fillText('MataTudo', W/2, H/2-10); ctx.globalAlpha=Math.max(0,a*0.8); ctx.font='16px ui-sans-serif,system-ui'; ctx.fillText('a tiny top-down shooter', W/2, H/2+22); ctx.globalAlpha=1; }
    else if(s.mode==='menu'){ ctx.fillStyle='rgba(0,0,0,0.55)'; ctx.fillRect(0,0,W,H); ctx.fillStyle='#fff'; ctx.font='bold 36px ui-sans-serif,system-ui'; ctx.fillText('MataTudo', W/2, H/2-60); ctx.font='16px ui-sans-serif,system-ui'; ctx.fillText('Click or press any key to start', W/2, H/2+8); ctx.fillText(`Best: ${s.bestScore}`, W/2, H/2+36); }
    else if(s.mode==='countdown'){ ctx.fillStyle='rgba(0,0,0,0.35)'; ctx.fillRect(0,0,W,H); ctx.fillStyle='#fff'; ctx.font='bold 48px ui-sans-serif,system-ui'; ctx.fillText(String(Math.max(1,Math.ceil(s.countdown))), W/2, H/2); }
    else if(s.mode==='gameover'){ /* overlay handled by HOF modal; keep map visible */ }
    ctx.textAlign='start';

    ctx.restore();
  }

  // ---------- Hall of Fame ----------
  function updateHallOfFame(){
    // session scores
    s.todayScores.push(s.score);
    s.todayScores.sort((a,b)=>b-a);
    if(s.todayScores.length>8) s.todayScores.length=8;

    // all-time
    let all=[];
    try { const raw = localStorage.getItem('matatudo_alltime'); if(raw) all = JSON.parse(raw)||[]; } catch {}
    all.push(s.score); all.sort((a,b)=>b-a); if(all.length>10) all.length=10;
    try { localStorage.setItem('matatudo_alltime', JSON.stringify(all)); } catch {}

    const acc = s.shotsFired>0 ? Math.round(100*s.shotsHit/s.shotsFired) : 0;
    hofSummary.textContent = `Score ${s.score} · Level ${s.level} · Accuracy ${acc}%`;

    boardToday.innerHTML = s.todayScores.map((sc,i)=>`<div class="line"><span>${String(i+1).padStart(2,'0')}</span><span>${String(sc).padStart(6,' ')}</span></div>`).join('');
    boardAll.innerHTML   = all.map((sc,i)=>`<div class="line"><span>${String(i+1).padStart(2,'0')}</span><span>${String(sc).padStart(6,' ')}</span></div>`).join('');
  }

  // ---------- Input ----------
  function toLocal(e){ const r=cvs.getBoundingClientRect(); s.mouse.x=(e.clientX-r.left)*(W/r.width); s.mouse.y=(e.clientY-r.top)*(H/r.height); }
  window.addEventListener('mousemove',toLocal);
  window.addEventListener('mousedown',e=>{ s.mouse.down=true; toLocal(e); if(s.mode==='intro'){ s.mode='menu'; stopAllMusic(); return; } if(s.mode==='menu'||s.mode==='gameover'){ startGame(); } });
  window.addEventListener('mouseup',()=>s.mouse.down=false);
  window.addEventListener('keydown',e=>{
    const k=e.key.toLowerCase(); if(!e.repeat) s.keys[k]=true;
    if(k==='m'){ toggleMute(); return; }
    if(k==='r'){ startGame(); return; }
    if(s.mode==='intro'){ s.mode='menu'; stopAllMusic(); return; }
    if(s.mode==='menu'){ startGame(); return; }
    if(s.mode==='gameover'){ startGame(); return; }
  });
  window.addEventListener('keyup',e=>{ s.keys[e.key.toLowerCase()]=false; });

  btnPause.addEventListener('click',()=>{ s.running=!s.running; btnPause.textContent=s.running?'Pause':'Resume'; });

  // ---------- Loop ----------
  let raf; function step(t){ if(!s.lastTime) s.lastTime=t; const dt=Math.min(0.033,(t-s.lastTime)/1000); s.lastTime=t; update(dt); draw(); raf=requestAnimationFrame(step); }
  raf=requestAnimationFrame(step);
  window.addEventListener('beforeunload',()=>{ cancelAnimationFrame(raf); stopAllMusic(); });
})();
</script>
</body>
</html>


