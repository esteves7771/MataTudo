<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>MataTudo — Alpha 12</title>
<style>
  :root { color-scheme: dark; }
  html, body { height: 100%; margin: 0; background:#0b1220; color:#fff; font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif;}
  .wrap { min-height: 100%; display:grid; place-items:center; padding:20px; }
  .panel { display:flex; flex-direction:column; gap:10px; align-items:center; }
  canvas { background:#000; border-radius:16px; border:1px solid rgba(255,255,255,.08); box-shadow:0 10px 30px rgba(0,0,0,.35); }
  .row { display:flex; gap:10px; align-items:center; flex-wrap:wrap; }
  .btn { padding:6px 10px; border-radius:10px; border:1px solid rgba(255,255,255,.2); background:transparent; color:#fff; cursor:pointer; }
  .btn:hover { border-color: rgba(255,255,255,.6); }
  .hint { font-size:12px; opacity:.8 }
  input[type="range"]{ width:120px; }
  .title { font-weight:700; font-size:18px; letter-spacing:.2px; }
</style>
</head>
<body>
<div class="wrap">
  <div class="panel">
    <div class="title">MataTudo — Alpha 12</div>
    <canvas id="game" width="1140" height="708"></canvas>
    <div class="row">
      <button id="pause" class="btn">Pause</button>
      <button id="mute" class="btn">Mute</button>
      <label>Vol <input id="vol" type="range" min="0" max="1" step="0.05" value="0.7"></label>
    </div>
    <div class="hint">WASD/Arrows move • Mouse aims • Click shoots • Any Key/Click starts • <b>R</b> restarts • <b>M</b> mutes • Level every 30 kills • Boss every 4 levels</div>
  </div>
</div>

<script>
(() => {
  // ---------- Config ----------
  const W = 1140, H = 708, MAP_MARGIN = 12;
  const LEVEL_KILLS = 30;                   // kills per level
  const MEDKIT_EVERY = 25;                  // kills
  const MUSIC_MAIN_URL  = "https://raw.githubusercontent.com/esteves7771/MataTudo/main/retro-synthwave-gaming-music-270173.mp3";
  const MUSIC_BOSS_URL  = "https://raw.githubusercontent.com/esteves7771/MataTudo/main/cyberpunk-gaming-144149.mp3";

  // Damage (kept reduced ~15%)
  const BOT_BULLET_DMG = 8.5;
  const BOT_TOUCH_DMG  = 8.5;

  // Map constraints
  const MAX_OBS_W = 240, MAX_OBS_H = 200, MIN_GAP = 28, SAFE_RING = 80;
  const GRID_CELLS_X = 45, GRID_CELLS_Y = 27;

  // ---------- DOM ----------
  const cvs = document.getElementById('game');
  const ctx = cvs.getContext('2d', { alpha:false });
  const btnPause = document.getElementById('pause');
  const btnMute = document.getElementById('mute');
  const vol = document.getElementById('vol');

  // ---------- Helpers ----------
  const clamp = (v, a, b) => Math.max(a, Math.min(b, v));
  const rand = (a,b)=>a+Math.random()*(b-a);
  const rectOverAny = (rect, arr) => arr.some(o => !(rect.x + rect.w < o.x || rect.x > o.x + o.w || rect.y + rect.h < o.y || rect.y > o.y + o.h));
  const rectCircleOverlap = (cx, cy, r, o) => { const nx = clamp(cx, o.x, o.x + o.w), ny = clamp(cy, o.y, o.y + o.h); const dx = cx - nx, dy = cy - ny; return dx*dx + dy*dy <= r*r; };
  const bulletHitsObstacle = (b, o) => (b.x + b.r > o.x && b.x - b.r < o.x + o.w && b.y + b.r > o.y && b.y - b.r < o.y + o.h);
  const entityBlockedBy = (x,y,r,obs) => obs.some(o => rectCircleOverlap(x,y,r,o));

  // Screen shake
  function addShake(s, mag=6, dur=0.2){ s.shakeMag = Math.max(s.shakeMag||0, mag); s.shakeT = Math.max(s.shakeT||0, dur); }
  function applyShake(s){ if ((s.shakeT||0) <= 0) return; s.shakeT -= s.dt; const m = (s.shakeMag||0) * (s.shakeT>0 ? (s.shakeT) : 0); ctx.translate((Math.random()*2-1)*m,(Math.random()*2-1)*m); }

  // Minimal push-out for circle/rect overlap
  function pushCircleOutOfRect(e, o){
    const {x:cx, y:cy, r} = e;
    const nx = clamp(cx, o.x, o.x + o.w), ny = clamp(cy, o.y, o.y + o.h);
    let dx = cx - nx, dy = cy - ny;
    let dist = Math.hypot(dx,dy);
    if (dist === 0){
      const left = Math.abs(cx - o.x), right = Math.abs((o.x + o.w) - cx);
      const top = Math.abs(cy - o.y), bottom = Math.abs((o.y + o.h) - cy);
      const m = Math.min(left,right,top,bottom);
      if (m === left) dx = -1, dy = 0; else if (m === right) dx = 1, dy = 0; else if (m === top) dx = 0, dy = -1; else dx = 0, dy = 1;
      dist = 1;
    }
    const overlap = r - dist;
    if (overlap > 0){
      const ux = dx / dist, uy = dy / dist;
      e.x += ux * (overlap + 0.75);
      e.y += uy * (overlap + 0.75);
      e.x = clamp(e.x, MAP_MARGIN + r, W - MAP_MARGIN - r);
      e.y = clamp(e.y, MAP_MARGIN + r, H - MAP_MARGIN - r);
      return true;
    }
    return false;
  }
  function resolveAllOverlaps(s){
    for (let k=0;k<5;k++){
      s.obstacles.forEach(o => { if (rectCircleOverlap(s.player.x, s.player.y, s.player.r, o)) pushCircleOutOfRect(s.player, o); });
      s.bots.forEach(b => { s.obstacles.forEach(o => { if (rectCircleOverlap(b.x,b.y,b.r,o)) pushCircleOutOfRect(b,o); }); });
    }
  }
  function insetToPlayArea(x,y,w,h){
    const left = MAP_MARGIN + MIN_GAP, top = MAP_MARGIN + MIN_GAP;
    const right = W - MAP_MARGIN - MIN_GAP, bottom = H - MAP_MARGIN - MIN_GAP;
    w = Math.min(w, right - left); h = Math.min(h, bottom - top);
    x = clamp(x, left, right - w); y = clamp(y, top, bottom - h);
    return { x, y, w, h };
  }

  // ---------- Audio ----------
  const audio = { ctx:null, master:null, sfxGain:null, muted:false, main:null, boss:null, current:'main' };
  function ensureAC() {
    if (audio.muted) return;
    if (!audio.ctx) {
      const AC = window.AudioContext || window.webkitAudioContext; if (!AC) return;
      const ac = new AC();
      const master = ac.createGain(); master.gain.value = parseFloat(vol.value); master.connect(ac.destination);
      const sfxGain = ac.createGain(); sfxGain.gain.value = 1.0; sfxGain.connect(master);
      audio.ctx = ac; audio.master = master; audio.sfxGain = sfxGain;
    } else if (audio.ctx.state === 'suspended') {
      audio.ctx.resume();
    }
  }
  function setVolume(x){ if (audio.master) audio.master.gain.value = x; if (audio.main) audio.main.volume = audio.muted?0:x; if (audio.boss) audio.boss.volume = audio.muted?0:x; }
  function toggleMute(){ audio.muted = !audio.muted; btnMute.textContent = audio.muted ? "Unmute" : "Mute"; setVolume(audio.muted ? 0 : parseFloat(vol.value)); if (audio.muted){ audio.main?.pause(); audio.boss?.pause(); } else if (s.mode==='playing'){ (audio.current==='boss'?audio.boss:audio.main)?.play().catch(()=>{}); } }
  vol.addEventListener('input', () => setVolume(parseFloat(vol.value)));
  btnMute.addEventListener('click', toggleMute);
  document.addEventListener('keydown', e => { if (e.key.toLowerCase() === 'm') toggleMute(); });

  function makeAudioEl(url){ const a = new Audio(url); a.loop = true; a.crossOrigin='anonymous'; a.preload='auto'; a.volume = parseFloat(vol.value); return a; }
  function startMainMusic(){ if (!audio.main) audio.main = makeAudioEl(MUSIC_MAIN_URL); if (!audio.muted) audio.main.play().catch(()=>{}); audio.current='main'; }
  function startBossMusic(){ if (!audio.boss) audio.boss = makeAudioEl(MUSIC_BOSS_URL); if (!audio.muted) audio.boss.play().catch(()=>{}); audio.current='boss'; }
  function stopAllMusic(){ audio.main?.pause(); audio.boss?.pause(); if (audio.main) audio.main.currentTime=0; if (audio.boss) audio.boss.currentTime=0; }

  function quickBeep(freq=800, dur=0.06, type='square', gain=0.03){
    if (audio.muted) return; ensureAC(); if (!audio.ctx) return;
    const ac = audio.ctx, osc = ac.createOscillator(), g = ac.createGain();
    osc.type = type; osc.frequency.value = freq; g.gain.value = gain;
    osc.connect(g).connect(audio.sfxGain);
    const now = ac.currentTime; g.gain.setValueAtTime(gain,now); g.gain.exponentialRampToValueAtTime(0.0001,now+dur);
    osc.start(now); osc.stop(now+dur);
  }
  function whoosh(){
    if (audio.muted) return; ensureAC(); if (!audio.ctx) return;
    const ac=audio.ctx; const noise=ac.createBuffer(1, ac.sampleRate*0.6, ac.sampleRate); const d=noise.getChannelData(0);
    for(let i=0;i<d.length;i++){ const t=i/d.length; d[i]=(Math.random()*2-1)*(1-t)*0.6; }
    const src=ac.createBufferSource(); src.buffer=noise;
    const bp=ac.createBiquadFilter(); bp.type='bandpass'; bp.frequency.setValueAtTime(400,ac.currentTime); bp.frequency.linearRampToValueAtTime(1200, ac.currentTime+0.6);
    const g=ac.createGain(); g.gain.value=0.05; g.gain.exponentialRampToValueAtTime(0.0001, ac.currentTime+0.6);
    src.connect(bp).connect(g).connect(audio.sfxGain); src.start();
  }
  function noiseBurst(dur=0.25, gain=0.05){
    if (audio.muted) return; ensureAC(); if (!audio.ctx) return;
    const ac = audio.ctx, buf = ac.createBuffer(1,ac.sampleRate*dur,ac.sampleRate), data = buf.getChannelData(0);
    for (let i=0;i<data.length;i++) data[i]=(Math.random()*2-1)*0.6;
    const src = ac.createBufferSource(); src.buffer = buf; const g = ac.createGain(); g.gain.value = gain; const lp = ac.createBiquadFilter(); lp.type='lowpass'; lp.frequency.value=1200;
    src.connect(lp).connect(g).connect(audio.sfxGain);
    const now=ac.currentTime; g.gain.setValueAtTime(gain,now); g.gain.exponentialRampToValueAtTime(0.0001,now+dur);
    src.start(now);
  }
  const SFX = {
    shot: () => quickBeep(1100,0.045,'square',0.03),
    hit:  () => quickBeep(280, 0.06,'sine',0.02),
    heal: () => quickBeep(900, 0.12,'triangle',0.035),
    death:(i=0.4)=>{ noiseBurst(0.22+0.15*i,0.04+0.06*i); quickBeep(200,0.3+0.15*i,'sawtooth',0.02+0.04*i); },
  };

  // ---------- State ----------
  const s = {
    time:0, lastTime:0, running:true, dt:0,
    mode:'intro', introTime:0, countdown:2,
    level:1, levelUpFlash:0, pendingBoss:false,
    score:0, bestScore:0,
    mult:1, multT:0,   // score multiplier & timer
    shotsFired:0, shotsHit:0,
    lastMedkitAtScore:0, lastEliteAtScore:0,
    player:{ x:W/2, y:H/2, r:12, speed:240, hp:100, fireCooldown:0, flashTimer:0, hitCooldown:0, knockbackX:0, knockbackY:0, kbT:0 },
    keys:{}, mouse:{ x:W/2, y:H/2, down:false },
    bullets:[], bots:[], particles:[], medkits:[], explosions:[], hazards:[],
    groundPattern:null,
    spawnTimer:0, firstWaveRemaining:4, firstWaveInterval:0.4, firstWaveTimer:0.4,
    obstacles:[
      { x:360,y:230,w:120,h:110 },
      { x:780,y:460,w:160,h:80 },
      { x:560,y:120,w:90,h:90 },
      { x:170,y:510,w:170,h:44 },
    ],
    obstacleAlpha:1, obstaclePhase:'stable', obstacleFadeT:0,
    shakeT:0, shakeMag:0,
    banner:null,                              // {text,t,dur}
    spawnEase:1.0, spawnEaseT:0,              // post-boss easing
    power:{ kind:null, t:0 }                  // {kind:'rapid'|'shotgun'|'explosive', t:seconds}
  };
  try { const saved = localStorage.getItem('matatudo_best'); if (saved) s.bestScore = parseInt(saved, 10) || 0; } catch {}

  // Background pattern
  ;(function(){
    const pc = document.createElement('canvas'); pc.width=64; pc.height=64;
    const pg = pc.getContext('2d');
    pg.fillStyle='#27303a'; pg.fillRect(0,0,64,64);
    for (let i=0;i<140;i++){ pg.fillStyle=`rgba(255,255,255,${0.06+Math.random()*0.06})`; pg.fillRect(Math.random()*64, Math.random()*64, 1, 1); }
    pg.strokeStyle='rgba(0,0,0,0.12)';
    for (let x=0;x<=64;x+=16){ pg.beginPath(); pg.moveTo(x,0); pg.lineTo(x,64); pg.stroke(); }
    for (let y=0;y<=64;y+=16){ pg.beginPath(); pg.moveTo(0,y); pg.lineTo(64,y); pg.stroke(); }
    s.groundPattern = ctx.createPattern(pc,'repeat');
  })();

  // ---------- Connectivity grid (map validity) ----------
  function buildGridFromObstacles(obstacles){
    const grid = Array.from({length:GRID_CELLS_Y}, ()=>Array(GRID_CELLS_X).fill(0));
    const cellW = (W - 2*MAP_MARGIN) / GRID_CELLS_X;
    const cellH = (H - 2*MAP_MARGIN) / GRID_CELLS_Y;
    for (let y=0;y<GRID_CELLS_Y;y++){
      for (let x=0;x<GRID_CELLS_X;x++){
        const cx = MAP_MARGIN + x*cellW + cellW/2;
        const cy = MAP_MARGIN + y*cellH + cellH/2;
        const rr = 12 + MIN_GAP/2;
        if (s.obstacles.some(o => rectCircleOverlap(cx, cy, rr, o))) grid[y][x] = 1;
      }
    }
    return { grid, cellW, cellH };
  }
  function bfsReach(grid, startX, startY){
    const Hh = grid.length, Ww = grid[0].length;
    const q=[[startX,startY]]; const seen = Array.from({length:Hh},()=>Array(Ww).fill(false));
    seen[startY][startX] = true; const dirs=[[1,0],[-1,0],[0,1],[0,-1]];
    while(q.length){ const [x,y]=q.shift(); for(const [dx,dy] of dirs){ const nx=x+dx, ny=y+dy; if(nx<0||ny<0||nx>=Ww||ny>=Hh) continue; if(seen[ny][nx]||grid[ny][nx]===1) continue; seen[ny][nx]=true; q.push([nx,ny]); } }
    return seen;
  }
  function gridCellFromXY(x,y,cellW,cellH){
    const gx = clamp(Math.floor((x - MAP_MARGIN)/cellW), 0, GRID_CELLS_X-1);
    const gy = clamp(Math.floor((y - MAP_MARGIN)/cellH), 0, GRID_CELLS_Y-1);
    return {gx, gy};
  }
  function doorsReachable(obstacles, px, py){
    const { grid, cellW, cellH } = (function(){
      const grid = Array.from({length:GRID_CELLS_Y}, ()=>Array(GRID_CELLS_X).fill(0));
      const cellW = (W - 2*MAP_MARGIN) / GRID_CELLS_X;
      const cellH = (H - 2*MAP_MARGIN) / GRID_CELLS_Y;
      for (let y=0;y<GRID_CELLS_Y;y++){
        for (let x=0;x<GRID_CELLS_X;x++){
          const cx = MAP_MARGIN + x*cellW + cellW/2;
          const cy = MAP_MARGIN + y*cellH + cellH/2;
          const rr = 12 + MIN_GAP/2;
          if (obstacles.some(o => rectCircleOverlap(cx, cy, rr, o))) grid[y][x] = 1;
        }
      }
      return {grid, cellW, cellH};
    })();
    const { gx, gy } = gridCellFromXY(px, py, cellW, cellH);
    if (grid[gy][gx]===1) return false;
    const seen = bfsReach(grid, gx, gy);
    const doors = [
      {gx: Math.floor(GRID_CELLS_X/2), gy: 0},
      {gx: Math.floor(GRID_CELLS_X/2), gy: GRID_CELLS_Y-1},
      {gx: 0,                        gy: Math.floor(GRID_CELLS_Y/2)},
      {gx: GRID_CELLS_X-1,           gy: Math.floor(GRID_CELLS_Y/2)},
    ];
    return doors.every(d => seen[d.gy][d.gx] === true);
  }

  // ---------- Map gen ----------
  function generateCandidateObstacles(currentEntities){
    const obstacles = [];
    const addRect = (x,y,w,h) => {
      w = Math.min(w, MAX_OBS_W); h = Math.min(h, MAX_OBS_H);
      let r = insetToPlayArea(x,y,w,h);
      const inflated = { x: r.x - MIN_GAP/2, y: r.y - MIN_GAP/2, w: r.w + MIN_GAP, h: r.h + MIN_GAP };
      if (rectOverAny(inflated, obstacles.map(o=>({x:o.x - MIN_GAP/2, y:o.y - MIN_GAP/2, w:o.w + MIN_GAP, h:o.h + MIN_GAP})))) return;
      const wouldCover = currentEntities.some(ent => rectCircleOverlap(ent.x, ent.y, ent.r + 2, r));
      if (wouldCover) return;
      obstacles.push(r);
    };
    const patternCount = 2 + Math.floor(Math.random()*2);
    for (let k=0;k<patternCount;k++){
      const pick = Math.floor(Math.random()*3);
      if (pick===0){
        const cx = MAP_MARGIN + 160 + Math.random()*(W-2*(MAP_MARGIN+160));
        const cy = MAP_MARGIN + 120 + Math.random()*(H-2*(MAP_MARGIN+120));
        const coreW = 80 + Math.random()*130, coreH = 60 + Math.random()*110;
        addRect(cx-coreW/2, cy-coreH/2, coreW, coreH);
        const n = 3 + Math.floor(Math.random()*4);
        for (let i=0;i<n;i++){
          const w = 40 + Math.random()*90, h = 30 + Math.random()*80;
          addRect(cx + (Math.random()*280-140) - w/2, cy + (Math.random()*200-100) - h/2, w, h);
        }
      } else if (pick===1){
        const bars = 3 + Math.floor(Math.random()*3);
        for (let i=0;i<bars;i++){
          const horiz = Math.random() < 0.5;
          if (horiz){
            const w = 180 + Math.random()*240, h = 22 + Math.random()*36;
            addRect(MAP_MARGIN + Math.random()*(W-2*MAP_MARGIN - w), MAP_MARGIN + Math.random()*(H-2*MAP_MARGIN - h), w, h);
          } else {
            const w = 22 + Math.random()*36, h = 180 + Math.random()*240;
            addRect(MAP_MARGIN + Math.random()*(W-2*MAP_MARGIN - w), MAP_MARGIN + Math.random()*(H-2*MAP_MARGIN - h), w, h);
          }
        }
      } else {
        const count = 7 + Math.floor(Math.random()*8);
        for (let i=0;i<count;i++){
          const w = 50 + Math.random()*120, h = 50 + Math.random()*120;
          addRect(MAP_MARGIN + Math.random()*(W-2*MAP_MARGIN - w), MAP_MARGIN + Math.random()*(H-2*MAP_MARGIN - h), w, h);
        }
      }
    }
    if (obstacles.length > 18) obstacles.length = 18;
    return obstacles;
  }
  function randomObstaclesNavigable(){
    const ents = [{x:s.player.x, y:s.player.y, r:SAFE_RING}].concat(s.bots.map(b=>({x:b.x,y:b.y,r:b.r+SAFE_RING*0.25})));
    for (let tries=0; tries<30; tries++){
      const obs = generateCandidateObstacles(ents);
      if (doorsReachable(obs, s.player.x, s.player.y)) return obs;
    }
    return s.obstacles;
  }
  function triggerObstacleSwap(){ s.obstaclePhase='fadeOut'; s.obstacleFadeT=0; }
  function relocateMedkitsIfBlocked(){
    s.medkits = s.medkits.filter(m => {
      if (!entityBlockedBy(m.x, m.y, m.r, s.obstacles)) return true;
      for (let i=0;i<40;i++){
        const r=10; const x=MAP_MARGIN+r + Math.random()*(W-2*(MAP_MARGIN+r)); const y=MAP_MARGIN+r + Math.random()*(H-2*(MAP_MARGIN+r));
        if (!entityBlockedBy(x,y,r,s.obstacles)){ m.x=x; m.y=y; return true; }
      }
      return false;
    });
  }
  function updateObstacleFade(dt){
    if (s.obstaclePhase==='stable') return;
    const DUR = 0.45; s.obstacleFadeT += dt; const t = clamp(s.obstacleFadeT / DUR, 0, 1);
    if (s.obstaclePhase==='fadeOut'){
      s.obstacleAlpha = 1 - t;
      if (s.obstacleFadeT >= DUR){
        s.obstacles = randomObstaclesNavigable();
        resolveAllOverlaps(s);
        relocateMedkitsIfBlocked();
        s.obstaclePhase='fadeIn'; s.obstacleFadeT = 0;
      }
    } else {
      s.obstacleAlpha = t;
      if (s.obstacleFadeT >= DUR){ s.obstaclePhase='stable'; s.obstacleAlpha=1; }
    }
  }

  // ---------- Hazards ----------
  function spawnHazards(n=2){
    for (let i=0;i<n;i++){
      const r=10, x=rand(MAP_MARGIN+50, W-MAP_MARGIN-50), y=rand(MAP_MARGIN+50, H-MAP_MARGIN-50);
      s.hazards.push({ x,y,r, vx:rand(-120,120), vy:rand(-120,120) });
    }
  }

  // ---------- Spawners / FX ----------
  function spawnParticles(x,y,color,count,size=2){
    for (let i=0;i<count;i++){
      const a = Math.random()*Math.PI*2, v=40+Math.random()*80;
      s.particles.push({ x,y, vx:Math.cos(a)*v, vy:Math.sin(a)*v, life:0.4+Math.random()*0.4, color, size });
    }
  }
  function spawnExplosion(x,y,scale=1,color='#ffcf6b'){
    s.explosions.push({ x,y, t:0, dur:0.35, r0:8*scale, r1:36*scale, color });
  }

  // Boss patterns
  function bossShootAimed(b){ const p=s.player; const a=Math.atan2(p.y-b.y,p.x-b.x)+(Math.random()-0.5)*0.1; const sp=460; s.bullets.push({x:b.x,y:b.y,vx:Math.cos(a)*sp,vy:Math.sin(a)*sp,r:3,owner:'bot',life:2,boss:true}); }
  function bossShootBurst(b){ const N=12, base=Math.random()*Math.PI*2; for(let i=0;i<N;i++){ const a=base+i*(Math.PI*2/N); const sp=380; s.bullets.push({x:b.x,y:b.y,vx:Math.cos(a)*sp,vy:Math.sin(a)*sp,r:3,owner:'bot',life:2,boss:true}); } }
  function bossShootSpiral(b){ b.spiralA=(b.spiralA||0)+0.35; const sp=400, a=b.spiralA; s.bullets.push({x:b.x,y:b.y,vx:Math.cos(a)*sp,vy:Math.sin(a)*sp,r:3,owner:'bot',life:2,boss:true}); }

  // Bot AI helpers
  function vectorToPlayer(b){ const dx=s.player.x-b.x, dy=s.player.y-b.y; const d=Math.hypot(dx,dy)||1; return {dx,dy,d,ax:dx/d,ay:dy/d}; }

  function spawnBot(elite=false, boss=false){
    let tries=0, x=0, y=0, r=boss?30:(elite?16:12);
    while (tries++<60){
      const edge=Math.floor(Math.random()*4);
      if (edge===0){ x = MAP_MARGIN + r + 2; y = rand(MAP_MARGIN, H-MAP_MARGIN); }
      else if (edge===1){ x = W - MAP_MARGIN - r - 2; y = rand(MAP_MARGIN, H-MAP_MARGIN); }
      else if (edge===2){ x = rand(MAP_MARGIN, W-MAP_MARGIN); y = MAP_MARGIN + r + 2; }
      else { x = rand(MAP_MARGIN, W-MAP_MARGIN); y = H - MAP_MARGIN - r - 2; }
      if (!entityBlockedBy(x,y,r,s.obstacles)) break;
    }
    const baseSpd = boss ? 70 : 80+Math.random()*35;
    const hp = boss? 770 : (elite?200:40);
    const speed = baseSpd * (1 + 0.08*(s.level-1)) * (elite?0.9:1);
    const shootEvery = (boss? 0.65 : (0.9 + Math.random()*0.9)) * (elite?0.85:1);

    let ai = 'rusher';
    if (!boss){
      const r = Math.random();
      ai = r<0.25? 'strafer' : r<0.5? 'circler' : r<0.75? 'sniper' : 'rusher';
    }

    let speedMul = 1, extraHP = 0, mod = null;
    if (!boss){
      if (Math.random() < 0.15){ speedMul = 1.35; mod = (mod||'') + 'S'; }
      if (Math.random() < 0.12){ extraHP = 40; mod = (mod||'') + 'H'; }
    }

    const bot = { x,y,r,speed:speed*speedMul,hp:hp+extraHP,fireCooldown:0,shootEvery,jitter:Math.random()*Math.PI*2, elite, boss, mod, outline: (boss? '#f88' : (mod? '#7cf' : null)), ai, phase:'aim',phaseT:0,spiralA:0 };
    s.bots.push(bot);
  }
  function spawnBossSolo(){
    s.bots = s.bots.filter(b=>b.boss);
    startBossMusic(); audio.main?.pause();
    s.banner = { text:'BOSS INCOMING!', t:0, dur:1.8 };
    whoosh();
    spawnBot(false,true);
  }
  function trySpawnMedkit(){
    if (s.score>0 && s.score%MEDKIT_EVERY===0 && s.lastMedkitAtScore!==s.score){
      for (let i=0;i<80;i++){
        const r=10; const x=MAP_MARGIN+r + Math.random()*(W-2*(MAP_MARGIN+r)); const y=MAP_MARGIN+r + Math.random()*(H-2*(MAP_MARGIN+r));
        if (entityBlockedBy(x,y,r,s.obstacles)) continue;
        s.medkits.push({ x,y,r,timeLeft:20, heal:30 }); s.lastMedkitAtScore = s.score; break;
      }
    }
  }
  function maybeDropPowerup(x,y){
    if (Math.random() < 0.08){ // 8% chance
      const pick = Math.random();
      const kind = pick<0.34? 'rapid' : pick<0.68? 'shotgun' : 'explosive';
      s.medkits.push({ x, y, r:11, timeLeft:18, power:kind }); // reuse medkits array as generic pickups
    }
  }

  // ---------- Leveling ----------
  function maybeLevelUp(){
    const nextLevel = Math.floor(s.score / LEVEL_KILLS) + 1;
    if (nextLevel > s.level){
      s.level = nextLevel; s.levelUpFlash = 2; triggerObstacleSwap();
      if (s.level % 4 === 0){ s.pendingBoss = true; }  // boss every 4 levels
      // add hazards gradually
      if (s.level % 3 === 0 && s.hazards.length < 5) spawnHazards(1);
    }
  }

  // ---------- Start/Reset ----------
  function startGame(){
    ensureAC(); stopAllMusic(); startMainMusic();
    s.player = { x:W/2, y:H/2, r:12, speed:240, hp:100, fireCooldown:0, flashTimer:0, hitCooldown:0, knockbackX:0, knockbackY:0, kbT:0 };
    s.bullets=[]; s.bots=[]; s.particles=[]; s.explosions=[];
    s.spawnTimer=0; s.score=0; s.mult=1; s.multT=0; s.lastEliteAtScore=0; s.lastMedkitAtScore=0;
    s.firstWaveRemaining=4; s.firstWaveTimer=s.firstWaveInterval;
    s.level=1; s.levelUpFlash=0; s.obstaclePhase='stable'; s.obstacleAlpha=1; s.pendingBoss=false;
    s.shotsFired=0; s.shotsHit=0; s.power={kind:null,t:0};
    s.spawnEase = 1.0; s.spawnEaseT = 0;
    // keep map & hazards persistent
    s.mode='countdown'; s.countdown=2;
  }

  // ---------- Update ----------
  function update(dt){
    s.dt = dt; s.time += dt; updateObstacleFade(dt);
    if (s.spawnEaseT>0){ s.spawnEaseT -= dt; s.spawnEase = 1 + 0.25*(s.spawnEaseT/20); if (s.spawnEaseT <= 0) s.spawnEase = 1; }
    if (s.banner){ s.banner.t += dt; if (s.banner.t >= s.banner.dur) s.banner = null; }
    if (s.power.kind){ s.power.t -= dt; if (s.power.t<=0){ s.power.kind=null; } }

    if (!s.running) return;

    if (s.mode==='intro'){ s.introTime += dt; if (s.introTime>1.6){ s.mode='menu'; stopAllMusic(); } return; }
    if (s.mode==='menu') return;
    if (s.mode==='countdown'){ s.countdown -= dt; if (s.countdown<=0){ s.mode='playing'; } return; }
    if (s.mode!=='playing') return;

    // Hazards update
    s.hazards.forEach(h => {
      h.x += h.vx*dt; h.y += h.vy*dt;
      if (h.x < MAP_MARGIN+h.r || h.x > W-MAP_MARGIN-h.r) h.vx *= -1;
      if (h.y < MAP_MARGIN+h.r || h.y > H-MAP_MARGIN-h.r) h.vy *= -1;
    });

    // Spawns (pause during boss or pending)
    const bossAlive = s.bots.some(b=>b.boss);
    s.spawnTimer -= dt;
    if (!bossAlive && !s.pendingBoss){
      const spawnBase = Math.max(0.5, 1.6 - Math.min(60, s.score/5)*0.01);
      const spawnScaled = Math.max(0.25, spawnBase * (1 - 0.06*(s.level-1))) * s.spawnEase;
      if (s.spawnTimer<=0){
        const eliteChance = Math.min(0.5, 0.05*s.level) * (s.spawnEaseT>0 ? 0.6 : 1);
        spawnBot(Math.random() < eliteChance, false);
        s.spawnTimer = spawnScaled;
      }
      if (s.firstWaveRemaining>0){
        s.firstWaveTimer -= dt; if (s.firstWaveTimer<=0){ spawnBot(false,false); s.firstWaveRemaining--; s.firstWaveTimer = s.firstWaveInterval; }
      }
      if (s.score>0 && s.score%20===0 && s.lastEliteAtScore !== s.score){ spawnBot(true,false); s.lastEliteAtScore = s.score; }
    }
    if (s.pendingBoss && !bossAlive){ spawnBossSolo(); s.pendingBoss = false; }

    // Player move (+knockback)
    const p = s.player;
    p.hitCooldown = Math.max(0, p.hitCooldown - dt);
    p.flashTimer = Math.max(0, p.flashTimer - dt);
    p.kbT = Math.max(0, p.kbT - dt);
    let ix=0, iy=0;
    if (s.keys['w']||s.keys['arrowup']) iy--;
    if (s.keys['s']||s.keys['arrowdown']) iy++;
    if (s.keys['a']||s.keys['arrowleft']) ix--;
    if (s.keys['d']||s.keys['arrowright']) ix++;
    const mag = Math.hypot(ix,iy) || 1;
    let mvx = ix/mag * p.speed * dt, mvy = iy/mag * p.speed * dt;
    if (p.kbT>0){ mvx += p.knockbackX * (p.kbT*4) * dt; mvy += p.knockbackY * (p.kbT*4) * dt; }
    let nx = clamp(p.x + mvx, MAP_MARGIN+p.r, W-MAP_MARGIN-p.r); if (!s.obstacles.some(o=>rectCircleOverlap(nx,p.y,p.r,o))) p.x = nx;
    let ny = clamp(p.y + mvy, MAP_MARGIN+p.r, H-MAP_MARGIN-p.r); if (!s.obstacles.some(o=>rectCircleOverlap(p.x,ny,p.r,o))) p.y = ny;

    // Shooting (powerups change pattern)
    p.fireCooldown -= dt;
    if (s.mouse.down && p.fireCooldown<=0){
      const dx = s.mouse.x - p.x, dy = s.mouse.y - p.y, d = Math.hypot(dx,dy) || 1;
      const baseAng = Math.atan2(dy,dx);
      let shots = 1, spread = 0, cooldown=0.15, speed=520;
      // baseline: L2 double, L5 triple
      if (s.level >= 5){ shots = 3; spread = 0.12; }
      else if (s.level >= 2){ shots = 2; spread = 0.07; }
      // powerups
      if (s.power.kind==='rapid'){ cooldown *= 0.5; }
      if (s.power.kind==='shotgun'){ shots = Math.max(shots, 5); spread = Math.max(spread, 0.2); speed = 500; }
      if (s.power.kind==='explosive'){ /* projectile flag set below */ }

      if (shots === 1){
        s.bullets.push({ x:p.x, y:p.y, vx:dx/d*speed, vy:dy/d*speed, r:3, owner:'player', life:2, explosive: s.power.kind==='explosive' });
      } else {
        const half = (shots-1)/2;
        for (let i=0;i<shots;i++){
          const t = i - half;
          const ang = baseAng + (t * spread);
          s.bullets.push({ x:p.x, y:p.y, vx:Math.cos(ang)*speed, vy:Math.sin(ang)*speed, r:3, owner:'player', life:2, explosive: s.power.kind==='explosive' });
        }
      }
      s.shotsFired += shots;
      spawnParticles(p.x+Math.cos(baseAng)*p.r, p.y+Math.sin(baseAng)*p.r, '#fff8', 6, 1.6);
      p.flashTimer = 0.07; p.fireCooldown = cooldown; SFX.shot();
    }

    // Bots AI + fire
    s.bots.forEach(b => {
      b.jitter = (b.jitter||0) + dt*2.2;
      const v = vectorToPlayer(b);

      let targetAx = v.ax, targetAy = v.ay;
      if (!b.boss){
        if (b.ai==='strafer'){
          const side = Math.sin(s.time*2 + b.jitter)>0 ? 1 : -1;
          const strafeAngle = Math.atan2(v.dy, v.dx) + side*Math.PI/2;
          targetAx = Math.cos(strafeAngle); targetAy = Math.sin(strafeAngle);
        } else if (b.ai==='circler'){
          const base = Math.atan2(v.dy, v.dx) + Math.sin(b.jitter)*0.5;
          targetAx = Math.cos(base); targetAy = Math.sin(base);
        } else if (b.ai==='sniper'){
          // back off if too close, otherwise small approach
          if (v.d < 260){ targetAx = -v.ax; targetAy = -v.ay; } else { targetAx = v.ax*0.3; targetAy = v.ay*0.3; }
        }
      }

      const totalDx = targetAx * b.speed * dt;
      const totalDy = targetAy * b.speed * dt;
      const steps = Math.max(1, Math.ceil(Math.hypot(totalDx,totalDy) / Math.max(1, b.r*0.6)));
      const stepX=totalDx/steps, stepY=totalDy/steps;
      for (let i=0;i<steps;i++){
        let tx = b.x + stepX, ty = b.y;
        if (!s.obstacles.some(o=>rectCircleOverlap(tx,b.y,b.r,o))) b.x = clamp(tx, MAP_MARGIN+b.r, W-MAP_MARGIN-b.r);
        ty = b.y + stepY;
        if (!s.obstacles.some(o=>rectCircleOverlap(b.x,ty,b.r,o))) b.y = clamp(ty, MAP_MARGIN+b.r, H-MAP_MARGIN-b.r);
      }

      // Fire patterns
      b.fireCooldown -= dt;
      if (b.boss){
        b.phaseT += dt;
        if (b.phase === 'aim'){
          if (b.fireCooldown<=0){ bossShootAimed(b); b.fireCooldown = 0.35; }
          if (b.phaseT > 3){ b.phase='burst'; b.phaseT=0; }
        } else if (b.phase === 'burst'){
          if (b.fireCooldown<=0){ bossShootBurst(b); b.fireCooldown = 1.1; }
          if (b.phaseT > 3.2){ b.phase='spiral'; b.phaseT=0; }
        } else { // spiral
          if (b.fireCooldown<=0){ bossShootSpiral(b); b.fireCooldown = 0.06; }
          if (b.phaseT > 3){ b.phase='aim'; b.phaseT=0; }
        }
      } else if (b.fireCooldown<=0){
        const dx=p.x-b.x, dy=p.y-b.y; const aa = Math.atan2(dy,dx) + (Math.random()-0.5)*0.18;
        const speed = 360;
        s.bullets.push({ x:b.x, y:b.y, vx:Math.cos(aa)*speed, vy:Math.sin(aa)*speed, r:3, owner:'bot', life:2 });
        b.fireCooldown = b.shootEvery * Math.max(0.55, 1 - 0.05*(s.level-1));
      }
    });

    // Bullets
    s.bullets.forEach(b => { b.x += b.vx*dt; b.y += b.vy*dt; b.life-=dt; });
    s.bullets = s.bullets.filter(b => b.life>0 && b.x>-10 && b.x<W+10 && b.y>-10 && b.y<H+10 && !s.obstacles.some(o=>bulletHitsObstacle(b,o)) );

    // Hazards damage
    s.hazards.forEach(h=>{
      if (Math.hypot(h.x-s.player.x, h.y-s.player.y) < h.r + s.player.r){
        if (s.player.hitCooldown<=0){ s.player.hp -= 10; s.player.hitCooldown=0.35; SFX.hit(); addShake(s,6,0.25); }
      }
      s.bots.forEach(b=>{ if (Math.hypot(h.x-b.x, h.y-b.y) < h.r + b.r){ b.hp -= 60*dt; } });
    });

    // Bot bullets → player
    s.bullets.forEach(b => {
      if (b.owner==='bot' && Math.hypot(b.x-p.x,b.y-p.y) < b.r + p.r){
        if (p.hitCooldown<=0){
          p.hp -= BOT_BULLET_DMG; p.hitCooldown = 0.35; spawnParticles(p.x,p.y,'#f00',8,2.2); SFX.hit(); addShake(s, 6, 0.25);
          p.knockbackX = (p.x - b.x) / (Math.hypot(p.x-b.x,p.y-b.y)||1); p.knockbackY = (p.y - b.y) / (Math.hypot(p.x-b.x,p.y-b.y)||1); p.kbT = 0.2;
          s.mult = 1; s.multT = 0; // reset multiplier when hit
        }
        b.life = 0;
      }
    });

    // Player bullets → bots (with explosive)
    s.bots = s.bots.filter(b => {
      let alive = true;
      s.bullets.forEach(proj => {
        if (proj.owner==='player' && Math.hypot(b.x-proj.x,b.y-proj.y) < (b.r+proj.r)){
          b.hp -= 25; proj.life = 0; spawnParticles(b.x,b.y,'#f33',10,2); SFX.hit(); s.shotsHit += 1;
          if (proj.explosive){ // splash
            spawnExplosion(proj.x,proj.y,1.1,'#ffa07a');
            s.bots.forEach(bb=>{ const d=Math.hypot(bb.x-proj.x,bb.y-proj.y); if (d<70){ bb.hp -= 22*(1-d/70); } });
          }
          if (b.hp<=0){
            alive = false;
            const over = -b.hp; const extra = 20 + Math.min(40, Math.max(0, Math.round(over*1.2)));
            spawnParticles(b.x,b.y,b.boss?'#ff8888':(b.elite?'#ffd372':'#ff7b72'), extra, 3);
            spawnExplosion(b.x,b.y, b.boss?1.8:(b.elite?1.2:1), b.boss?'#ff6666':'#ffb16b');
            if (over > 30 || b.boss) addShake(s, b.boss?12:8, 0.35);
            // Score (multiplier)
            const base = b.boss ? 5 : (b.elite ? 2 : 1);
            s.multT = Math.min(5, s.multT + 1.25); s.mult = Math.min(5, 1 + Math.floor(s.multT)); // step up streak
            s.score += base * s.mult;
            if (b.boss){
              s.medkits.push({ x:b.x, y:b.y, r:12, timeLeft:30, heal:60 });
              // soften post-boss for 20s
              s.spawnEaseT = 20; s.spawnEase = 1.25;
              // music back to main
              audio.boss?.pause(); startMainMusic();
            } else {
              maybeDropPowerup(b.x,b.y);
            }
            SFX.death(Math.min(1, over/50));
            maybeLevelUp();
          }
        }
      });
      return alive;
    });

    // Touch damage
    s.bots.forEach(b => {
      if (Math.hypot(b.x-p.x,b.y-p.y) < b.r + p.r){
        if (p.hitCooldown<=0){
          p.hp -= BOT_TOUCH_DMG; p.hitCooldown = 0.35; spawnParticles(p.x,p.y,'#f00',8,2.2); SFX.hit(); addShake(s, 6, 0.25);
          p.knockbackX = (p.x - b.x) / (Math.hypot(p.x-b.x,p.y-b.y)||1); p.knockbackY = (p.y - b.y) / (Math.hypot(p.x-b.x,p.y-b.y)||1); p.kbT = 0.25;
          s.mult = 1; s.multT = 0;
        }
      }
    });

    // Pickups: medkits & powerups
    trySpawnMedkit();
    s.medkits.forEach(m => m.timeLeft -= dt);
    s.medkits = s.medkits.filter(m => {
      if (m.timeLeft<=0) return false;
      if (Math.hypot(m.x - p.x, m.y - p.y) < m.r + p.r){
        if (m.power){
          s.power.kind = m.power; s.power.t = 15; // 15s duration
          spawnParticles(m.x,m.y,'#c8f7ff',18,2.6);
        } else {
          p.hp = Math.min(100, p.hp + (m.heal||30)); spawnParticles(m.x,m.y,'#8cff8c',18,2.6); SFX.heal();
        }
        return false;
      }
      return true;
    });

    // Explosions & particles
    s.explosions.forEach(ex => { ex.t += dt; }); s.explosions = s.explosions.filter(ex => ex.t < ex.dur);
    s.particles.forEach(pt => { pt.x+=pt.vx*dt; pt.y+=pt.vy*dt; pt.life-=dt; }); s.particles = s.particles.filter(pt => pt.life>0);

    // Death
    if (p.hp<=0){
      s.mode='gameover'; stopAllMusic();
      try { if (s.score > (s.bestScore||0)) { s.bestScore = s.score; localStorage.setItem('matatudo_best', String(s.bestScore)); } } catch {}
    }

    // Level up flash decay
    s.levelUpFlash = Math.max(0, s.levelUpFlash - dt);
  }

  // ---------- Drawing ----------
  function drawSoldier(x,y,ang,r,flash,lowHP){
    ctx.save(); ctx.translate(x,y); ctx.rotate(ang);
    ctx.fillStyle='rgba(0,0,0,0.25)'; ctx.beginPath(); ctx.ellipse(0,r*0.9,r*0.9,r*0.4,0,0,Math.PI*2); ctx.fill();
    const g=ctx.createRadialGradient(0,-r*0.2,r*0.2,0,0,r*1.05); g.addColorStop(0,lowHP?'#ff7b7b':'#34d27a'); g.addColorStop(1,lowHP?'#b33':'#228d4e');
    ctx.fillStyle=g; ctx.beginPath(); ctx.arc(0,0,r,0,Math.PI*2); ctx.fill();
    ctx.fillStyle='#1e824c'; ctx.beginPath(); ctx.arc(0,-r*0.3,r*0.95,Math.PI,0); ctx.fill();
    ctx.fillStyle='#145a32'; ctx.fillRect(-r,-r*0.3,r*2,r*0.15);
    ctx.fillStyle='#2ecc71'; ctx.fillRect(-r*1.2,-r*0.4,r*0.4,r*1.2); ctx.fillRect(r*0.8,-r*0.4,r*0.4,r*1.2);
    ctx.fillStyle='#dcdcdc'; ctx.fillRect(0,-3,r+14,6);
    ctx.fillStyle='#555'; ctx.fillRect(r+14,-2,4,4);
    if (flash>0){ ctx.fillStyle='rgba(255,240,120,0.9)'; ctx.beginPath(); ctx.ellipse(r+20,0,7,3.5,0,0,Math.PI*2); ctx.fill(); }
    ctx.restore();
  }
  function drawObstacle(o, alpha=1){
    ctx.save(); ctx.globalAlpha = alpha;
    ctx.fillStyle='#4b5563'; ctx.fillRect(o.x,o.y,o.w,o.h);
    ctx.strokeStyle='rgba(0,0,0,0.25)'; ctx.strokeRect(o.x+0.5,o.y+0.5,o.w-1,o.h-1);
    ctx.fillStyle='rgba(255,255,255,0.08)';
    for (let i=0;i<30;i++){ const rx=o.x+4+Math.random()*(o.w-8), ry=o.y+4+Math.random()*(o.h-8); ctx.fillRect(rx,ry,1,1); }
    ctx.restore();
  }
  function drawBossTexture(b){
    const r=b.r;
    const grad = ctx.createRadialGradient(b.x- r*0.2, b.y- r*0.2, r*0.2, b.x, b.y, r*1.2);
    grad.addColorStop(0, '#ff6b6b'); grad.addColorStop(1, '#b81616');
    ctx.fillStyle = grad; ctx.beginPath(); ctx.arc(b.x,b.y,r,0,Math.PI*2); ctx.fill();
    ctx.save(); ctx.clip(); ctx.globalAlpha=0.18;
    ctx.strokeStyle='#ffffff'; ctx.lineWidth=2;
    for(let a=-r; a<=r; a+=6){ ctx.beginPath(); ctx.moveTo(b.x - r, b.y + a); ctx.lineTo(b.x + r, b.y + a + 8); ctx.stroke(); }
    ctx.restore();
  }
  function drawExplosions(){
    s.explosions.forEach(ex => {
      const t = ex.t / ex.dur;
      const r = ex.r0 + (ex.r1 - ex.r0)*t;
      const a = 1 - t;
      ctx.save();
      ctx.globalAlpha = a * 0.9;
      ctx.strokeStyle = ex.color; ctx.lineWidth = 3;
      ctx.beginPath(); ctx.arc(ex.x, ex.y, r, 0, Math.PI*2); ctx.stroke();
      ctx.globalAlpha = a * 0.35;
      ctx.fillStyle = ex.color; ctx.beginPath(); ctx.arc(ex.x, ex.y, r*0.6, 0, Math.PI*2); ctx.fill();
      ctx.restore();
    });
  }
  function draw(){
    ctx.save();
    applyShake(s);

    ctx.fillStyle = s.groundPattern || '#0b1220'; ctx.fillRect(0,0,W,H);
    // Low-HP border pulse
    const low = s.player.hp <= 25 && s.mode==='playing';
    if (low){ const pulse = (Math.sin(s.time*10)+1)/2; ctx.strokeStyle = `rgba(255,70,70,${0.2+0.6*pulse})`; ctx.lineWidth = 4; ctx.strokeRect(MAP_MARGIN-2,MAP_MARGIN-2,W-2*MAP_MARGIN+4,H-2*MAP_MARGIN+4); }
    ctx.strokeStyle='rgba(255,255,255,0.2)'; ctx.lineWidth = 1; ctx.strokeRect(MAP_MARGIN,MAP_MARGIN,W-2*MAP_MARGIN,H-2*MAP_MARGIN);

    s.obstacles.forEach(o=>drawObstacle(o, s.obstacleAlpha));

    // Hazards
    s.hazards.forEach(h=>{ ctx.fillStyle='#fbbf24'; ctx.beginPath(); ctx.arc(h.x,h.y,h.r,0,Math.PI*2); ctx.fill(); ctx.strokeStyle='#b45309'; ctx.lineWidth=2; ctx.beginPath(); ctx.arc(h.x,h.y,h.r+3,0,Math.PI*2); ctx.stroke(); });

    // pickups
    s.medkits.forEach(m => {
      const blink = m.timeLeft<5 ? (Math.floor(m.timeLeft*10)%2===0) : true; if(!blink) return;
      const r=m.r;
      if (m.power){
        ctx.fillStyle='#c8f7ff'; ctx.beginPath(); ctx.arc(m.x,m.y,r,0,Math.PI*2); ctx.fill();
        ctx.fillStyle='#0ea5e9'; ctx.font='10px ui-sans-serif'; ctx.textAlign='center'; ctx.fillText(m.power[0].toUpperCase(), m.x, m.y+3); ctx.textAlign='start';
      } else {
        ctx.fillStyle='#e5f7ff'; ctx.fillRect(m.x-r,m.y-r,r*2,r*2);
        ctx.strokeStyle='#94a3b8'; ctx.strokeRect(m.x-r+0.5,m.y-r+0.5,r*2-1,r*2-1);
        ctx.fillStyle='#e11d48'; ctx.fillRect(m.x-r*0.25,m.y-r*0.8,r*0.5,r*1.6); ctx.fillRect(m.x-r*0.8,m.y-r*0.25,r*1.6,r*0.5);
      }
    });

    const p = s.player; const ang = Math.atan2(s.mouse.y-p.y,s.mouse.x-p.x); drawSoldier(p.x,p.y,ang,p.r,p.flashTimer, low);

    s.bots.forEach(b=>{
      ctx.save();
      if (b.outline){ ctx.strokeStyle=b.outline; ctx.lineWidth=3; ctx.beginPath(); ctx.arc(b.x,b.y,b.r+3,0,Math.PI*2); ctx.stroke(); }
      if (b.boss) drawBossTexture(b); else { ctx.fillStyle = b.elite?'#f0c420':'#ff7b72'; ctx.beginPath(); ctx.arc(b.x,b.y,b.r,0,Math.PI*2); ctx.fill(); }
      ctx.strokeStyle='rgba(255,255,255,0.6)'; ctx.lineWidth=2; ctx.beginPath();
      const maxHP = b.boss?770:(b.elite?200:40); const frac=Math.max(0,b.hp)/maxHP;
      ctx.arc(b.x,b.y,b.r+4,-Math.PI/2,-Math.PI/2+frac*Math.PI*2); ctx.stroke();
      ctx.restore();
    });

    s.bullets.forEach(b=>{ ctx.fillStyle = b.owner==='player'?'#e6ff71':(b.boss?'#ffb1b1':'#ffa8a3'); ctx.beginPath(); ctx.arc(b.x,b.y,b.r,0,Math.PI*2); ctx.fill(); });
    s.particles.forEach(pt=>{ ctx.fillStyle=pt.color; ctx.beginPath(); ctx.arc(pt.x,pt.y,pt.size,0,Math.PI*2); ctx.fill(); });
    drawExplosions();

    // HUD
    ctx.fillStyle='#fff'; ctx.font='14px ui-sans-serif,system-ui';
    const acc = s.shotsFired>0 ? Math.round(100*s.shotsHit/s.shotsFired) : 0;
    ctx.fillText(`Score: ${s.score}  (x${s.mult})`, 12, 20);
    ctx.fillText(`HP: ${Math.max(0,Math.round(s.player.hp))}`, 12, 40);
    ctx.fillText(`Level: ${s.level}  Power: ${s.power.kind? s.power.kind+' '+Math.ceil(s.power.t)+'s' : '-'}`, 12, 60);

    // overlays
    ctx.textAlign='center';
    if (s.levelUpFlash > 0 && Math.floor(s.time*6)%2===0){
      ctx.font='bold 28px ui-sans-serif,system-ui'; ctx.fillText('Level Up!', W/2, MAP_MARGIN + 34);
    }
    if (s.banner){
      const alpha = 1 - Math.max(0, (s.banner.t/s.banner.dur) - 0.6);
      ctx.globalAlpha = Math.max(0, alpha);
      ctx.fillStyle='rgba(0,0,0,0.55)'; ctx.fillRect(0,0,W,H);
      ctx.fillStyle='#fff'; ctx.font='bold 40px ui-sans-serif,system-ui'; ctx.fillText(s.banner.text, W/2, H/2);
      ctx.globalAlpha = 1;
    }
    if (s.mode==='intro'){
      ctx.fillStyle='rgba(0,0,0,0.7)'; ctx.fillRect(0,0,W,H);
      ctx.fillStyle='#fff'; const t=s.time; const alpha = Math.min(1, t/0.5) * (t<1.2?1:Math.max(0,2-t));
      ctx.globalAlpha = alpha; ctx.font='bold 48px ui-sans-serif,system-ui'; ctx.fillText('MataTudo', W/2, H/2 - 10);
      ctx.globalAlpha = Math.max(0, alpha*0.8); ctx.font='16px ui-sans-serif,system-ui'; ctx.fillText('a tiny top-down shooter', W/2, H/2 + 22); ctx.globalAlpha = 1;
    } else if (s.mode==='menu'){
      ctx.fillStyle='rgba(0,0,0,0.55)'; ctx.fillRect(0,0,W,H);
      ctx.fillStyle='#fff'; ctx.font='bold 36px ui-sans-serif,system-ui'; ctx.fillText('MataTudo', W/2, H/2-60);
      ctx.font='16px ui-sans-serif,system-ui'; ctx.fillText('WASD/Arrows move • Mouse aims • Click shoots', W/2, H/2-20);
      ctx.fillText('Click or press any key to start', W/2, H/2+10);
      ctx.fillText(`Best: ${s.bestScore}   Accuracy: ${acc}%`, W/2, H/2+40);
      ctx.font='12px ui-sans-serif,system-ui'; ctx.fillText('Press M to Mute/Unmute', W/2, H/2+64);
    } else if (s.mode==='countdown'){
      ctx.fillStyle='rgba(0,0,0,0.35)'; ctx.fillRect(0,0,W,H);
      ctx.fillStyle='#fff'; ctx.font='bold 48px ui-sans-serif,system-ui'; ctx.fillText(String(Math.max(1,Math.ceil(s.countdown))), W/2, H/2);
    } else if (s.mode==='gameover'){
      ctx.fillStyle='rgba(0,0,0,0.6)'; ctx.fillRect(0,0,W,H);
      ctx.fillStyle='#fff'; ctx.font='bold 28px ui-sans-serif,system-ui'; ctx.fillText('Game Over', W/2, H/2-20);
      ctx.font='16px ui-sans-serif,system-ui';
      ctx.fillText(`Score: ${s.score}   Best: ${s.bestScore}`, W/2, H/2+8);
      ctx.fillText(`Level Reached: ${s.level}   Accuracy: ${acc}%`, W/2, H/2+32);
      ctx.fillText('Press R or click to restart', W/2, H/2+56);
    }
    ctx.textAlign='start';

    ctx.restore(); // undo shake
  }

  // ---------- Input ----------
  function toLocalCoords(e){ const r = cvs.getBoundingClientRect(); s.mouse.x = (e.clientX - r.left) * (W / r.width); s.mouse.y = (e.clientY - r.top) * (H / r.height); }
  window.addEventListener('mousemove', toLocalCoords);
  window.addEventListener('mousedown', e => { s.mouse.down = true; toLocalCoords(e); if (s.mode==='intro'){ s.mode='menu'; stopAllMusic(); return; } if (s.mode==='menu' || s.mode==='gameover'){ startGame(); } });
  window.addEventListener('mouseup', () => s.mouse.down = false);
  window.addEventListener('keydown', e => {
    const k = e.key.toLowerCase();
    if (!e.repeat) s.keys[k] = true;
    if (k==='m'){ toggleMute(); return; }
    if (k==='r'){ startGame(); return; }
    if (s.mode==='intro'){ s.mode='menu'; stopAllMusic(); return; }
    if (s.mode==='menu'){ startGame(); return; }
    if (s.mode==='gameover'){ startGame(); return; }
  });
  window.addEventListener('keyup', e => { s.keys[e.key.toLowerCase()] = false; });

  // Pause button
  btnPause.addEventListener('click', () => { s.running = !s.running; btnPause.textContent = s.running ? 'Pause' : 'Resume'; });

  // ---------- Loop ----------
  let raf;
  function step(t){
    if (!s.lastTime) s.lastTime = t;
    const dt = Math.min(0.033, (t - s.lastTime) / 1000);
    s.lastTime = t;
    update(dt);
    draw();
    raf = requestAnimationFrame(step);
  }
  raf = requestAnimationFrame(step);

  // ---------- Clean up ----------
  window.addEventListener('beforeunload', () => { cancelAnimationFrame(raf); stopAllMusic(); });

})();
</script>
</body>
</html>

